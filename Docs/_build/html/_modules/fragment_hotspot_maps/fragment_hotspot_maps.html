
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>fragment_hotspot_maps.fragment_hotspot_maps &#8212; Fragment Hotspot Maps 0.1 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for fragment_hotspot_maps.fragment_hotspot_maps</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">More information about the fragment hotspot maps method is available from:</span>
<span class="sd">    Radoux, C.J. et. al., Identifying the Interactions that Determine Fragment Binding at Protein Hotspots J. Med. Chem.</span>
<span class="sd">    2016, 59 (9), 4314-4325</span>
<span class="sd">    dx.doi.org/10.1021/acs.jmedchem.5b01980</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">operator</span>

<span class="kn">from</span> <span class="nn">os.path</span> <span class="k">import</span> <span class="n">join</span><span class="p">,</span> <span class="n">dirname</span><span class="p">,</span> <span class="n">exists</span>
<span class="kn">from</span> <span class="nn">os</span> <span class="k">import</span> <span class="n">environ</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">getcwd</span><span class="p">,</span> <span class="n">mkdir</span><span class="p">,</span> <span class="n">chdir</span><span class="p">,</span> <span class="n">system</span><span class="p">,</span> <span class="n">path</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">subprocess</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">ccdc.io</span> <span class="k">import</span> <span class="n">csd_directory</span><span class="p">,</span> <span class="n">MoleculeWriter</span><span class="p">,</span> <span class="n">MoleculeReader</span>
<span class="kn">from</span> <span class="nn">ccdc.protein</span> <span class="k">import</span> <span class="n">Protein</span>
<span class="kn">from</span> <span class="nn">ccdc.utilities</span> <span class="k">import</span> <span class="n">Grid</span><span class="p">,</span> <span class="n">_test_output_dir</span><span class="p">,</span> <span class="n">PushDir</span>
<span class="kn">from</span> <span class="nn">ccdc</span> <span class="k">import</span> <span class="n">molecule</span>

<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">optimize</span><span class="p">,</span> <span class="n">ndimage</span>
<span class="kn">from</span> <span class="nn">skimage</span> <span class="k">import</span> <span class="n">feature</span>
<span class="kn">import</span> <span class="nn">pkg_resources</span>
<span class="kn">from</span> <span class="nn">template_strings</span> <span class="k">import</span> <span class="n">pymol_template</span><span class="p">,</span> <span class="n">colourmap</span><span class="p">,</span> <span class="n">superstar_ins</span><span class="p">,</span> <span class="n">extracted_hotspot_template</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">from</span> <span class="nn">concurrent</span> <span class="k">import</span> <span class="n">futures</span>
<span class="kn">from</span> <span class="nn">pprint</span> <span class="k">import</span> <span class="n">pprint</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">rdkit</span> <span class="k">import</span> <span class="n">Chem</span>
    <span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="k">import</span> <span class="n">Draw</span>
    <span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="k">import</span> <span class="n">AllChem</span>
    <span class="kn">from</span> <span class="nn">matplotlib.colors</span> <span class="k">import</span> <span class="n">LinearSegmentedColormap</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;ImportError: rdkit(optional)</span><span class="se">\n</span><span class="s2">Info: This module is required for producing 2D schematic maps&quot;&quot;&quot;</span><span class="p">)</span>
<span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;nt&#39;</span><span class="p">:</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">_HotspotsHelper</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    class providing utility functions</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_indices_to_point</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return x,y,z coordinate for a given grid index</span>

<span class="sd">        :param i: int, indice (x-axis)</span>
<span class="sd">        :param j: int, indice (y-axis)</span>
<span class="sd">        :param k: int, indice (z-axis)</span>
<span class="sd">        :param g: a :class: `ccdc.utilities.Grid` instance</span>
<span class="sd">        :return: float(x), float(y), float(z)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ox</span><span class="p">,</span> <span class="n">oy</span><span class="p">,</span> <span class="n">oz</span><span class="p">,</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">gs</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="k">return</span> <span class="n">ox</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">gs</span><span class="p">,</span> <span class="n">oy</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">gs</span><span class="p">,</span> <span class="n">oz</span> <span class="o">+</span> <span class="n">gs</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_point_to_indices</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the nearest grid index for a given point</span>

<span class="sd">        :param p: tup, (float(x), float(y), float(z)), a coordinate on a 3D grid</span>
<span class="sd">        :param g: a :class: `ccdc.utilities.Grid` instance</span>
<span class="sd">        :return: int(x), int(y), int(z)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">gs</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="n">rx</span><span class="p">,</span> <span class="n">ry</span><span class="p">,</span> <span class="n">rz</span> <span class="o">=</span> <span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="n">gs</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">p</span><span class="p">]</span>
        <span class="n">ox</span><span class="p">,</span> <span class="n">oy</span><span class="p">,</span> <span class="n">oz</span> <span class="o">=</span> <span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="n">gs</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">rx</span> <span class="o">-</span> <span class="n">ox</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">ry</span> <span class="o">-</span> <span class="n">oy</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">rz</span> <span class="o">-</span> <span class="n">oz</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_distance</span><span class="p">(</span><span class="n">coords1</span><span class="p">,</span> <span class="n">coords2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        given two coordinates, calculates the distance</span>

<span class="sd">        :param coords1: tup, (float(x), float(y), float(z), coordinates of point 1</span>
<span class="sd">        :param coords2: tup, (float(x), float(y), float(z), coordinates of point 2</span>
<span class="sd">        :return: float, distance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xd</span> <span class="o">=</span> <span class="n">coords1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">coords2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">yd</span> <span class="o">=</span> <span class="n">coords1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">coords2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">zd</span> <span class="o">=</span> <span class="n">coords1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">coords2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">xd</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">yd</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">zd</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_copy_and_clear</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        make a new empty grid</span>

<span class="sd">        :param grid: a :class: `ccdc.utilities.Grid` instance</span>
<span class="sd">        :return: an empty :class: `ccdc.utilities.Grid` instance</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">g</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">g</span> <span class="o">*=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">g</span>

    <span class="k">def</span> <span class="nf">_common_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        finds a common frame of reference for two grids</span>

<span class="sd">        :param g1: a :class: `ccdc.utilities.Grid` instance</span>
<span class="sd">        :param g2: a :class: `ccdc.utilities.Grid` instance</span>
<span class="sd">        :param padding: int, additional grid point in x, y, z directions</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">sg</span> <span class="o">=</span> <span class="n">Grid</span><span class="o">.</span><span class="n">super_grid</span><span class="p">(</span><span class="n">padding</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">)</span>
        <span class="n">out_g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy_and_clear</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span>
        <span class="n">out1</span> <span class="o">=</span> <span class="n">Grid</span><span class="o">.</span><span class="n">super_grid</span><span class="p">(</span><span class="n">padding</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">out_g</span><span class="p">)</span>
        <span class="n">out2</span> <span class="o">=</span> <span class="n">Grid</span><span class="o">.</span><span class="n">super_grid</span><span class="p">(</span><span class="n">padding</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">out_g</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out1</span><span class="p">,</span> <span class="n">out2</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">contains_point</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">island</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>

        <span class="n">mini</span> <span class="o">=</span> <span class="n">island</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">maxi</span> <span class="o">=</span> <span class="n">island</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">island</span><span class="o">.</span><span class="n">value_at_point</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">all</span><span class="p">([</span><span class="n">mini</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">tolerance</span> <span class="o">&lt;</span> <span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">maxi</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">tolerance</span><span class="p">,</span>
                        <span class="n">mini</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">tolerance</span> <span class="o">&lt;</span> <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">maxi</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">tolerance</span><span class="p">,</span>
                        <span class="n">mini</span><span class="o">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">tolerance</span> <span class="o">&lt;</span> <span class="n">point</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">maxi</span><span class="o">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">tolerance</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">grid_score</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">percentile</span><span class="o">=</span><span class="mi">75</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        take a group and return average score of points above threshold</span>
<span class="sd">        :param g:</span>
<span class="sd">        :param threshold</span>
<span class="sd">        :param percentile</span>

<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">nsteps</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nz</span><span class="p">)</span>
                  <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">percentile</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_lines_from_file</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        fetch lines from ghecom output</span>

<span class="sd">        :return: str, lines from output file</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)):</span>
            <span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">lines</span>


<span class="k">class</span> <span class="nc">_RunSuperstar</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    class to handle SuperStar run</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">class</span> <span class="nc">Settings</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        setting for Superstar run</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jobname</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">probename</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">moleculefile</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cavity_origin</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># self.occulsionthreshold = 5</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mapbackgroundvalue</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">boxborder</span> <span class="o">=</span> <span class="mi">10</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">minpropensity</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">superstar_executable</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">superstar_env</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">working_directory</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="n">settings</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;settings&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">settings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Settings</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="n">settings</span>

        <span class="n">main_dir</span> <span class="o">=</span> <span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;MAINDIR&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">main_dir</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s1">&#39;win32&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">superstar_executable</span> <span class="o">=</span> <span class="s1">&#39;superstar_app.exe&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">superstar_executable</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">join</span><span class="p">(</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;MAINDIR&#39;</span><span class="p">],</span> <span class="s1">&#39;run.sh&#39;</span><span class="p">),</span> <span class="s1">&#39;superstar_app.x&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">superstar_env</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s1">&#39;win32&#39;</span><span class="p">:</span>
                <span class="n">base</span> <span class="o">=</span> <span class="n">dirname</span><span class="p">(</span><span class="n">csd_directory</span><span class="p">())</span>
                <span class="n">merc</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;mercury*&#39;</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">merc</span><span class="p">):</span>
                    <span class="n">merc</span> <span class="o">=</span> <span class="n">merc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">superstar_executable</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">merc</span><span class="p">,</span> <span class="s1">&#39;superstar_app.exe&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">superstar_env</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">SUPERSTAR_ISODIR</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">(</span><span class="n">csd_directory</span><span class="p">()),</span> <span class="s1">&#39;isostar_files&#39;</span><span class="p">,</span> <span class="s1">&#39;istr&#39;</span><span class="p">)),</span>
                    <span class="n">SUPERSTAR_ROOT</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">(</span><span class="n">csd_directory</span><span class="p">()),</span> <span class="s2">&quot;Mercury&quot;</span><span class="p">))</span>
                <span class="p">)</span>

            <span class="k">elif</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s1">&#39;darwin&#39;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;OS X not supported&quot;</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">superstar_executable</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">(</span><span class="n">csd_directory</span><span class="p">()),</span> <span class="s1">&#39;bin&#39;</span><span class="p">,</span> <span class="s1">&#39;superstar&#39;</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">superstar_env</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">SUPERSTAR_ISODIR</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">(</span><span class="n">csd_directory</span><span class="p">()),</span> <span class="s1">&#39;isostar_files&#39;</span><span class="p">,</span> <span class="s1">&#39;istr&#39;</span><span class="p">)),</span>
                    <span class="n">SUPERSTAR_ROOT</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">dirname</span><span class="p">(</span><span class="n">csd_directory</span><span class="p">()))</span>
                <span class="p">)</span>
                <span class="c1"># self.settings.working_directory = _test_output_dir()</span>
                <span class="c1"># print(self.settings.working_directory)</span>

    <span class="k">def</span> <span class="nf">_append_cavity_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        updates ins file with any cavity information</span>

<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">cavity_origin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pnt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">cavity_origin</span>
            <span class="n">extension</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">CAVITY_ORIGIN </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pnt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pnt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pnt</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">extension</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">SUBSTRUCTURE ALL&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ins</span> <span class="o">+=</span> <span class="n">extension</span>

    <span class="k">def</span> <span class="nf">_get_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_dir</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        assembles the ins files, uses a template string from template_strings.py</span>

<span class="sd">        :param out_dir: str, output directory</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ins</span> <span class="o">=</span> <span class="n">superstar_ins</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_append_cavity_info</span><span class="p">()</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="s2">&quot;ins&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">mkdir</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="nb">print</span><span class="p">(</span><span class="n">getcwd</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fname</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;superstar_</span><span class="si">{}</span><span class="s2">.ins&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">jobname</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fname</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
            <span class="n">w</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ins</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run_superstar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prot</span><span class="p">,</span> <span class="n">out_dir</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        calls SuperStar as command-line subprocess</span>

<span class="sd">        :param prot: a :class:`ccdc.protein.Protein` instance</span>
<span class="sd">        :param out_dir: str, output directory</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="n">PushDir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">working_directory</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">prot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">MoleculeWriter</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;protein.pdb&#39;</span><span class="p">))</span> <span class="k">as</span> <span class="n">writer</span><span class="p">:</span>
                    <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">prot</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_inputs</span><span class="p">(</span><span class="n">out_dir</span><span class="p">)</span>
            <span class="n">env</span> <span class="o">=</span> <span class="n">environ</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">env</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">superstar_env</span><span class="p">)</span>
            <span class="n">cmd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">superstar_executable</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">fname</span>
            <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">!=</span> <span class="s1">&#39;win32&#39;</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="n">env</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_SuperstarResult</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_SuperstarResult</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    class to store a SuperStar result</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="n">settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">jobname</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">grid_path</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">working_directory</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span> <span class="o">+</span> <span class="s2">&quot;.ins.acnt&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">exists</span><span class="p">(</span><span class="n">grid_path</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">Grid</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">grid_path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> superstar grid could not be found&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">))</span>

        <span class="n">ligsite_path</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">working_directory</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span> <span class="o">+</span> <span class="s2">&quot;.ins.ligsite.acnt&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">exists</span><span class="p">(</span><span class="n">grid_path</span><span class="p">):</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">Grid</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">ligsite_path</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ligsite</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">correct_ligsite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> ligsite grid could not be found&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">correct_ligsite</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Grid points where ligsite has a score of 0 (i.e. a clash) and SuperStar has a favourable score, set the ligsite</span>
<span class="sd">        grid point to its maximum neighbour</span>

<span class="sd">        :param g:</span>
<span class="sd">        :param l:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="p">((</span><span class="n">l</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">g</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">lc</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">lc</span> <span class="o">=</span> <span class="n">lc</span><span class="o">.</span><span class="n">max_value_of_neighbours</span><span class="p">()</span>
        <span class="n">correction</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">lc</span>
        <span class="n">correction</span> <span class="o">=</span> <span class="n">correction</span><span class="o">.</span><span class="n">mean_value_of_neighbours</span><span class="p">()</span>
        <span class="n">corrected</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="n">correction</span>
        <span class="k">return</span> <span class="n">corrected</span>


<span class="k">class</span> <span class="nc">_RunGhecom</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    class to handle ghecom run</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">class</span> <span class="nc">Settings</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        settings for ghecom run</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ghecom_executable</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid_spacing</span> <span class="o">=</span> <span class="mf">0.5</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">radius_min_large_sphere</span> <span class="o">=</span> <span class="mf">2.5</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">radius_max_large_sphere</span> <span class="o">=</span> <span class="mf">9.5</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prot</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">out_grid</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="s2">&quot;M&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">working_directory</span> <span class="o">=</span> <span class="n">_test_output_dir</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">in_name</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">working_directory</span><span class="p">,</span> <span class="s2">&quot;protein.pdb&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">out_name</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">working_directory</span><span class="p">,</span> <span class="s2">&quot;ghecom_out.pdb&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param kw: settings for ghecom run</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">settings</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;settings&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">settings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Settings</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="n">settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">prot</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">out_grid</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">run_ghecom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        runs ghecom in temporary directory</span>

<span class="sd">        :return: a :class: `GhecomResult` instance</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="n">PushDir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">working_directory</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">prot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">MoleculeWriter</span><span class="p">(</span><span class="s1">&#39;protein.pdb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">writer</span><span class="p">:</span>
                    <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">prot</span><span class="p">)</span>

            <span class="n">cmd</span> <span class="o">=</span> <span class="s2">&quot;./ghecom </span><span class="si">{}</span><span class="s2"> -M </span><span class="si">{}</span><span class="s2"> -gw </span><span class="si">{}</span><span class="s2"> -rli </span><span class="si">{}</span><span class="s2"> -rlx </span><span class="si">{}</span><span class="s2"> -opoc </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">in_name</span><span class="p">,</span>
                                                                             <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span>
                                                                             <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">grid_spacing</span><span class="p">,</span>
                                                                             <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">radius_min_large_sphere</span><span class="p">,</span>
                                                                             <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">radius_max_large_sphere</span><span class="p">,</span>
                                                                             <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">out_name</span><span class="p">)</span>
            <span class="n">chdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">ghecom_executable</span><span class="p">)</span>
            <span class="n">system</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_GhecomResult</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_GhecomResult</span><span class="p">(</span><span class="n">_HotspotsHelper</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    class to store a Ghecom result</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="n">settings</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">out_grid</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">out_grid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initalise_grid</span><span class="p">(</span><span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_grid</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_initalise_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        install grid over protein to hold scores</span>

<span class="sd">        :param padding: value of buffer added to coordinate extremities</span>
<span class="sd">        :return: a `ccdc.utilities.Grid` instance</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">atm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">prot</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atm</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
            <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atm</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
            <span class="n">z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atm</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>

        <span class="n">bl</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">padding</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">padding</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">-</span> <span class="n">padding</span><span class="p">)</span>
        <span class="n">tr</span> <span class="o">=</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">padding</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">padding</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="n">padding</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Grid</span><span class="p">(</span><span class="n">origin</span><span class="o">=</span><span class="n">bl</span><span class="p">,</span> <span class="n">far_corner</span><span class="o">=</span><span class="n">tr</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        update initialised grid with ghecom vales</span>

<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lines_from_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">out_name</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;HETATM&quot;</span><span class="p">):</span>
                <span class="n">coordinates</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">31</span><span class="p">:</span><span class="mi">38</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">39</span><span class="p">:</span><span class="mi">46</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">47</span><span class="p">:</span><span class="mi">54</span><span class="p">]))</span>
                <span class="n">rinacc</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">61</span><span class="p">:</span><span class="mi">66</span><span class="p">])</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_point_to_indices</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">nsteps</span>
                <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">z</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mf">9.5</span> <span class="o">-</span> <span class="n">rinacc</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_WeightedResult</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    class to hold weighted grids</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">identifier</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span> <span class="o">=</span> <span class="n">identifier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span>


<span class="k">class</span> <span class="nc">_HotspotBuilder</span><span class="p">(</span><span class="n">_HotspotsHelper</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to handle the extraction of discrete, fragment size hotspots from the original maps</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampled_probes</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">apolar_islands</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polar_islands</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">donor_id</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acceptor_id</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">positive_id</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">negative_id</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Settings</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">Settings</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Default settings for hotspot extraction</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kw</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            default values</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">s</span> <span class="o">=</span> <span class="mf">0.2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sigma&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">min_distance</span> <span class="o">=</span> <span class="mi">6</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;cutoff&quot;</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">volume</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;volume&quot;</span><span class="p">,</span> <span class="mi">75</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid_points</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="p">)</span> <span class="o">/</span> <span class="mf">0.125</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_probes</span> <span class="o">=</span> <span class="mi">50</span>

    <span class="k">def</span> <span class="nf">deduplicate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param major:</span>
<span class="sd">        :param minor:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">filtered</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">jsland</span> <span class="ow">in</span> <span class="n">minor</span><span class="o">.</span><span class="n">islands</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="mi">14</span><span class="p">):</span>
            <span class="n">remove_island</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">point</span> <span class="o">=</span> <span class="p">((</span><span class="n">jsland</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">jsland</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                     <span class="p">(</span><span class="n">jsland</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">jsland</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                     <span class="p">(</span><span class="n">jsland</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">jsland</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">z</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                     <span class="p">)</span>
            <span class="k">for</span> <span class="n">island</span> <span class="ow">in</span> <span class="n">major</span><span class="o">.</span><span class="n">islands</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="mi">14</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains_point</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">island</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
                    <span class="n">remove_island</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">remove_island</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">filtered</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jsland</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy_and_clear</span><span class="p">(</span><span class="n">minor</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Grid</span><span class="o">.</span><span class="n">super_grid</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">filtered</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_apolar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        locate peaks in apolar maps and define fragment size volume</span>


<span class="sd">        :param super_grids:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">apolar_volume</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="s2">&quot;apolar&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="s2">&quot;apolar&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_gaussian</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">apolar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="s2">&quot;apolar&quot;</span><span class="p">]</span>
        <span class="n">peaks_dic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_close</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local_max</span><span class="p">(</span><span class="n">apolar</span><span class="p">))</span>

        <span class="n">sorted_keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">peaks_dic</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">islands</span> <span class="o">=</span> <span class="n">apolar</span><span class="o">.</span><span class="n">islands</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">cutoff</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">filtered_islands</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">islands</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">count_grid</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sorted_keys</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">cutoff</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># empirical cutoff, lower quartile (may need to change)</span>
                <span class="n">point</span> <span class="o">=</span> <span class="n">peaks_dic</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">filtered_islands</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains_point</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="n">agrid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_surrounding_points</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_score</span><span class="p">(</span><span class="n">agrid</span><span class="p">,</span> <span class="n">percentile</span><span class="o">=</span><span class="mi">75</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">12</span><span class="p">:</span>
                            <span class="n">apolar_volume</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">m</span><span class="p">:</span> <span class="n">agrid</span><span class="p">})</span>

        <span class="k">return</span> <span class="n">apolar_volume</span>

    <span class="k">def</span> <span class="nf">remove_close</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peak_dic</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        min distance</span>

<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_peak_dic</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">sorted_keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">peak_dic</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">score</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sorted_keys</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">new_peak_dic</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">score</span><span class="p">:</span> <span class="n">peak_dic</span><span class="p">[</span><span class="n">score</span><span class="p">]})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">([</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_distance</span><span class="p">(</span><span class="n">peak_dic</span><span class="p">[</span><span class="n">score</span><span class="p">],</span> <span class="n">peak_dic</span><span class="p">[</span><span class="n">sorted_keys</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span> <span class="o">&lt;</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">min_distance</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_peak_dic</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">score</span><span class="p">:</span> <span class="n">peak_dic</span><span class="p">[</span><span class="n">sorted_keys</span><span class="p">[</span><span class="n">i</span><span class="p">]]})</span>

        <span class="k">return</span> <span class="n">new_peak_dic</span>

    <span class="k">def</span> <span class="nf">polar_selection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        multiprocess</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">probe</span><span class="p">,</span> <span class="n">island</span><span class="p">,</span> <span class="n">apolar_items</span> <span class="o">=</span> <span class="n">variables</span>

        <span class="n">mols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_island_probes</span><span class="p">(</span><span class="n">island</span><span class="p">,</span> <span class="n">probe</span><span class="p">)</span>
        <span class="n">selection_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="nb">len</span><span class="p">([</span><span class="n">mol</span> <span class="k">for</span> <span class="n">mol</span> <span class="ow">in</span> <span class="n">mols</span>
                                  <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains_point</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">local</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">3</span><span class="p">)])</span>
                          <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">local</span> <span class="ow">in</span> <span class="n">apolar_items</span><span class="p">}</span>

        <span class="n">ident</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polar_identity</span><span class="p">(</span><span class="n">selection_dict</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ident</span><span class="p">,</span> <span class="n">island</span>

    <span class="k">def</span> <span class="nf">sort_by_island</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grids</span><span class="p">,</span> <span class="nb">max</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">islands_dict</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_score</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">percentile</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span> <span class="n">g</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">}</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">islands_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">islands_dict</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">(),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="nb">max</span><span class="p">]</span> <span class="k">if</span> <span class="n">key</span> <span class="o">&gt;</span> <span class="mi">14</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param dict:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">dict</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="nb">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort_by_island</span><span class="p">(</span><span class="nb">dict</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="nb">max</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">continue</span>
        <span class="k">return</span> <span class="nb">dict</span>

    <span class="k">def</span> <span class="nf">construct_hotspot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        handles the assignment of polar features to apolar volumes</span>

<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apolar_islands</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">donor_id</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">i</span><span class="p">:</span> <span class="p">[]})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">acceptor_id</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">i</span><span class="p">:</span> <span class="p">[]})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">positive_id</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">i</span><span class="p">:</span> <span class="p">[]})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">negative_id</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">i</span><span class="p">:</span> <span class="p">[]})</span>

        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polar_islands</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">probe</span><span class="p">,</span> <span class="n">islands</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polar_islands</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">probe</span><span class="p">)</span>
            <span class="n">apolar_items</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apolar_islands</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[(</span><span class="n">probe</span><span class="p">,</span> <span class="n">isl</span><span class="p">,</span> <span class="n">apolar_items</span><span class="p">)</span> <span class="k">for</span> <span class="n">isl</span> <span class="ow">in</span> <span class="n">islands</span><span class="p">]</span>
            <span class="n">pprint</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="n">multipro</span> <span class="o">=</span> <span class="n">futures</span><span class="o">.</span><span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">multipro</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polar_selection</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">probe</span> <span class="o">==</span> <span class="s2">&quot;donor&quot;</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">donor_id</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">elif</span> <span class="n">probe</span> <span class="o">==</span> <span class="s2">&quot;acceptor&quot;</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">acceptor_id</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">elif</span> <span class="n">probe</span> <span class="o">==</span> <span class="s2">&quot;positive&quot;</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">positive_id</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">elif</span> <span class="n">probe</span> <span class="o">==</span> <span class="s2">&quot;negative&quot;</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">negative_id</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">continue</span>

                    <span class="c1"># self.donor_id = self.filter(self.donor_id)</span>
                    <span class="c1"># self.acceptor_id = self.filter(self.acceptor_id)</span>
                    <span class="c1"># self.negative_id = self.filter(self.negative_id)</span>
                    <span class="c1"># self.positive_id = self.filter(self.positive_id)</span>

    <span class="k">def</span> <span class="nf">_polar_identity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selection_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        given a dictionary {key: []} the method will return the key for the item with longest list value</span>

<span class="sd">        :param selection_dict:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">identity</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">selection_dict</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">identity</span>

    <span class="k">def</span> <span class="nf">_get_island_probes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">island</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        select polar probes which are located in high scoring islands</span>

<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># print(self.sampled_probes[p])</span>
        <span class="n">ip</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampled_probes</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains_point</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">island</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">2</span><span class="p">)]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">max_probes</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ip</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">max_probes</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ip</span>

    <span class="k">def</span> <span class="nf">_surrounding_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">island</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        in development</span>

<span class="sd">        :param point:</span>
<span class="sd">        :param island:</span>
<span class="sd">        :param m:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy_and_clear</span><span class="p">(</span><span class="n">island</span><span class="p">)</span>
        <span class="n">dist_dic</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">island</span><span class="o">.</span><span class="n">nsteps</span>
        <span class="n">all_points</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_indices_to_point</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">island</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span>
                      <span class="nb">range</span><span class="p">(</span><span class="n">nz</span><span class="p">)</span> <span class="k">if</span> <span class="n">island</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">cutoff</span> <span class="o">-</span> <span class="mi">5</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">all_points</span><span class="p">:</span>
            <span class="n">rank</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mf">0.1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_distance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">point</span><span class="p">)))</span> <span class="o">*</span> <span class="n">island</span><span class="o">.</span><span class="n">value_at_point</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">rank</span> <span class="ow">in</span> <span class="n">dist_dic</span><span class="p">:</span>
                <span class="n">dist_dic</span><span class="p">[</span><span class="n">rank</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dist_dic</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="nb">float</span><span class="p">(</span><span class="n">rank</span><span class="p">):</span> <span class="p">[</span><span class="n">p</span><span class="p">]})</span>

        <span class="n">top_points</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">((</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">dist_dic</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_point_to_indices</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">island</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">top_points</span> <span class="k">for</span> <span class="n">pts</span> <span class="ow">in</span> <span class="n">dist_dic</span><span class="p">[</span><span class="n">r</span><span class="p">]]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">grid_points</span><span class="p">]:</span>
            <span class="n">mask</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">island</span> <span class="o">*</span> <span class="n">mask</span>
        <span class="n">new</span><span class="o">.</span><span class="n">max_value_of_neighbours</span><span class="p">()</span>
        <span class="n">minimal</span> <span class="o">=</span> <span class="n">Grid</span><span class="o">.</span><span class="n">super_grid</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">*</span><span class="n">new</span><span class="o">.</span><span class="n">islands</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_gaussian</span><span class="p">(</span><span class="n">minimal</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">local_max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        in development</span>
<span class="sd">        :param g:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">nsteps</span>
        <span class="n">peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nz</span><span class="p">):</span>
                    <span class="n">peaks</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">g</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

        <span class="n">peaks_indices</span> <span class="o">=</span> <span class="n">feature</span><span class="o">.</span><span class="n">peak_local_max</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span> <span class="n">min_distance</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">peaks_dic</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">peaks_indices</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices_to_point</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">g</span><span class="p">)</span>
            <span class="n">peaks_dic</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">g</span><span class="o">.</span><span class="n">value_at_point</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span> <span class="n">coords</span><span class="p">})</span>

        <span class="k">return</span> <span class="n">peaks_dic</span>

    <span class="k">def</span> <span class="nf">_run_gaussian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        gaussian smoothing function, method of reducing noise in output</span>

<span class="sd">        :param g:</span>
<span class="sd">        :param sigma:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">nsteps</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nz</span><span class="p">):</span>
                    <span class="n">scores</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">g</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

        <span class="n">mod</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
        <span class="n">new_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy_and_clear</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nz</span><span class="p">):</span>
                    <span class="n">new_grid</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">mod</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">new_grid</span>


<span class="k">class</span> <span class="nc">_SampleGrid</span><span class="p">(</span><span class="n">_HotspotsHelper</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    class to handle sampled grids</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">atom_predicate</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        attributes of SampleGrid</span>

<span class="sd">        :param name: str, name of probe (donor, acceptor, apolar, positive, negative)</span>
<span class="sd">        :param grid: a :class: `ccdc.utilities.Grid` instance</span>
<span class="sd">        :param atom_predicate: atom_predicate will be used to select atoms of a molecule for sampling</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atom_predicate</span> <span class="o">=</span> <span class="n">atom_predicate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">add_coordinates</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">trans</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        provides a coordinate list of atoms to be scored be scored in the SampleGrid</span>

<span class="sd">        :param coord: tup, (float(x), float(y), float(z)), set of atomic coordinates for &quot;active&quot; coordinates</span>
<span class="sd">        :param trans: tup, (float(x), float(y), float(z)), set of translations to translate probes to points</span>
<span class="sd">        above threshold</span>
<span class="sd">        :return: list of tup</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">trans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">trans</span><span class="p">))]</span>

    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinate_list</span><span class="p">,</span> <span class="n">trans</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        score Molecule in grids for which it has active atoms</span>

<span class="sd">        :param coordinate_list: list, set of coordinates of translated and rotated probe atoms to be scored</span>
<span class="sd">        :param trans:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">add_coordinates</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">trans</span><span class="p">))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coordinate_list</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">set_molecule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">polar_contribution</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        set which atoms match the grid</span>
<span class="sd">        probes with polar atoms contribute do not contribute to apolar maps as this leads to artefacts</span>

<span class="sd">        :param mol:</span>
<span class="sd">        :param polar_contribution:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="n">mol</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;apolar&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">polar_contribution</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">([</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span>
                                                                     <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_donor</span> <span class="ow">or</span> <span class="n">a</span><span class="o">.</span><span class="n">is_acceptor</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_active_atoms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_active_atoms&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_active_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_predicate</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_donor</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns true if a given atom is a donor</span>

<span class="sd">        :param a: a `ccdc.molecule.Atom` instance</span>
<span class="sd">        :return: bool, true if the atom classification is &quot;donor&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_donor</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">formal_charge</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_acceptor</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns true if a given atom is a acceptor</span>

<span class="sd">        :param a: a `ccdc.molecule.Atom` instance</span>
<span class="sd">        :return: bool, true if the atom classification is &quot;acceptor&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_acceptor</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">formal_charge</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_apolar</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns true if a given atom is a apolar</span>

<span class="sd">        :param a: a `ccdc.molecule.Atom` instance</span>
<span class="sd">        :return: bool, true if the atom classification is &quot;apolar&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_donor</span> <span class="ow">or</span> <span class="n">a</span><span class="o">.</span><span class="n">is_acceptor</span> <span class="ow">or</span> <span class="n">a</span><span class="o">.</span><span class="n">formal_charge</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">a</span><span class="o">.</span><span class="n">atomic_symbol</span> <span class="o">==</span> <span class="s2">&quot;Xe&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_positive</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns true if a given atom is a positively charged</span>

<span class="sd">        :param a: a `ccdc.molecule.Atom` instance</span>
<span class="sd">        :return: bool, true if the atom is positively charged</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">formal_charge</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_negative</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns true if a given atom is a negatively charged</span>

<span class="sd">        :param a: a `ccdc.molecule.Atom` instance</span>
<span class="sd">        :return: bool, true if the atom is negatively charged</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">formal_charge</span> <span class="o">&lt;</span> <span class="mi">0</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_aromatic</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns true if a given atom is aromatic</span>

<span class="sd">        :param a: a `ccdc.molecule.Atom` instance</span>
<span class="sd">        :return: bool, true if the atom is aromatic</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">atomic_symbol</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">is_cyclic</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">atom_type</span> <span class="o">==</span> <span class="s1">&#39;aromatic&#39;</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">bonds</span><span class="p">)</span>

<div class="viewcode-block" id="HotspotResults"><a class="viewcode-back" href="../../hotspot_api.html#fragment_hotspot_maps.fragment_hotspot_maps.HotspotResults">[docs]</a><span class="k">class</span> <span class="nc">HotspotResults</span><span class="p">(</span><span class="n">_HotspotsHelper</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Hotspot_results object is returned at the end of a Hotspots calculation. It contains functions for accessing</span>
<span class="sd">    and using the results.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid_dict</span><span class="p">,</span> <span class="n">protein</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">sampled_probes</span><span class="p">,</span> <span class="n">buriedness</span><span class="p">,</span> <span class="n">out_dir</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span> <span class="o">=</span> <span class="n">grid_dict</span>
            <span class="k">for</span> <span class="n">probe</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grid_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">bounding_box</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Not a valid Grid&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">prot</span> <span class="o">=</span> <span class="n">protein</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fname</span> <span class="o">=</span> <span class="n">fname</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buriedness</span> <span class="o">=</span> <span class="n">buriedness</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_dir</span> <span class="o">=</span> <span class="n">out_dir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">features_by_score</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">donor_scores</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acceptor_scores</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apolar_scores</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># self.sampled_probes = self.filter_by_score(sampled_probes)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampled_probes</span> <span class="o">=</span> <span class="n">sampled_probes</span>

<div class="viewcode-block" id="HotspotResults.filter_by_score"><a class="viewcode-back" href="../../hotspot_api.html#fragment_hotspot_maps.fragment_hotspot_maps.HotspotResults.filter_by_score">[docs]</a>    <span class="k">def</span> <span class="nf">filter_by_score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sampled_probes</span><span class="p">,</span> <span class="n">score</span><span class="o">=</span><span class="mi">16</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        filter sampled probes by score (reduce searching)</span>
<span class="sd">        :param sampled_probes: dict</span>
<span class="sd">        :param score:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sampled_probes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">probe</span><span class="p">:</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mols</span> <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">identifier</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">score</span><span class="p">]</span> <span class="k">for</span> <span class="n">probe</span><span class="p">,</span> <span class="n">mols</span> <span class="ow">in</span>
                    <span class="n">sampled_probes</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">_combine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        combines multiple grid objects in a single grid</span>
<span class="sd">        :return: a :class: `ccdc.utilities.Grid` instance</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">sg</span> <span class="o">=</span> <span class="n">Grid</span><span class="o">.</span><span class="n">super_grid</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">out_g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy_and_clear</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">probe</span><span class="p">:</span> <span class="n">Grid</span><span class="o">.</span><span class="n">super_grid</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">out_g</span><span class="p">)</span> <span class="k">for</span> <span class="n">probe</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="k">def</span> <span class="nf">_minimal_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        takes a results object and produces minimal common grid. (reduces memory required to store grids)</span>

<span class="sd">        :return: a :class: `ccdc.utilities.Grid` instance</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">probe</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="n">probe</span><span class="p">]</span> <span class="o">=</span> <span class="n">Grid</span><span class="o">.</span><span class="n">super_grid</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">g</span><span class="o">.</span><span class="n">islands</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_histogram_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        data for the matplotlib figure</span>

<span class="sd">        :param data:</span>
<span class="sd">        :param key:</span>
<span class="sd">        :param n:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">colour_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;acceptor&quot;</span><span class="p">:</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="s2">&quot;donor&quot;</span><span class="p">:</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;apolar&quot;</span><span class="p">:</span> <span class="s2">&quot;y&quot;</span><span class="p">}</span>
        <span class="n">hist</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">40</span><span class="p">),</span> <span class="n">normed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">hist</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colour_dict</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.35</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">([])</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Fragment-hotspot Maps&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">([])</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Fragment hotspot score&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Frequency&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_generate_histogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        initialise the matplotlib figure to output histograms</span>

<span class="sd">        :param data:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_histogram_info</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s2">&quot;hotspot_histogram.png&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<div class="viewcode-block" id="HotspotResults.hotspot_histograms"><a class="viewcode-back" href="../../hotspot_api.html#fragment_hotspot_maps.fragment_hotspot_maps.HotspotResults.hotspot_histograms">[docs]</a>    <span class="k">def</span> <span class="nf">hotspot_histograms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ligand</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Outputs histograms of hotspot score.</span>

<span class="sd">        :param ligand:</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">ligand</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bs_centroid</span> <span class="o">=</span> <span class="n">ligand</span><span class="o">.</span><span class="n">centre_of_geometry</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">grd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="n">g</span><span class="p">]</span>
                <span class="n">fragment_centroid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_point_to_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bs_centroid</span><span class="p">,</span> <span class="n">grd</span><span class="p">)</span>
                <span class="n">n</span> <span class="o">=</span> <span class="mi">8</span>
                <span class="n">rx</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">fragment_centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">n</span><span class="p">,</span> <span class="n">fragment_centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span>
                <span class="n">ry</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">fragment_centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">n</span><span class="p">,</span> <span class="n">fragment_centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span>
                <span class="n">rz</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">fragment_centroid</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">n</span><span class="p">,</span> <span class="n">fragment_centroid</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">g</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">grd</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rx</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ry</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">rz</span> <span class="k">if</span> <span class="n">grd</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">grd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="n">g</span><span class="p">]</span>
                <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">grd</span><span class="o">.</span><span class="n">nsteps</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">g</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">grd</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nx</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nz</span><span class="p">)</span> <span class="k">if</span>
                     <span class="n">grd</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_generate_histogram</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span></div>

<div class="viewcode-block" id="HotspotResults.get_selectivity_map"><a class="viewcode-back" href="../../hotspot_api.html#fragment_hotspot_maps.fragment_hotspot_maps.HotspotResults.get_selectivity_map">[docs]</a>    <span class="k">def</span> <span class="nf">get_selectivity_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Generate maps to highlight selectivity for a target over an off target cavity. Proteins should be aligned</span>
<span class="sd">        by the binding site of interest prior to calculation of Fragment Hotspot Maps. High scoring regions of a map</span>
<span class="sd">        represent areas of favourable interaction in the target binding site, not present in off target binding site</span>

<span class="sd">        :param other: a :class:`fragment_hotspots.Hotspots.HotspotResults` instance</span>
<span class="sd">        :return: a :class:`fragment_hotspots.Hotspots.HotspotResults` instance</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">selectivity_grids</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">probe</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">g1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="n">probe</span><span class="p">]</span>
            <span class="n">g2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="n">probe</span><span class="p">]</span>
            <span class="n">og1</span><span class="p">,</span> <span class="n">og2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_common_grid</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">)</span>
            <span class="n">sele</span> <span class="o">=</span> <span class="n">og1</span> <span class="o">-</span> <span class="n">og2</span>
            <span class="n">selectivity_grids</span><span class="p">[</span><span class="n">probe</span><span class="p">]</span> <span class="o">=</span> <span class="n">sele</span>
        <span class="n">hr</span> <span class="o">=</span> <span class="n">Hotspots</span><span class="o">.</span><span class="n">HotspotResults</span><span class="p">(</span><span class="n">selectivity_grids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fname</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_dir</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hr</span></div>

    <span class="k">def</span> <span class="nf">_get_near_score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">atom_type</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Searches nearby grid points and returns the maximum score&#39;&#39;&#39;</span>

        <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_point_to_indices</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="n">atom_type</span><span class="p">])</span>
        <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="n">atom_type</span><span class="p">]</span><span class="o">.</span><span class="n">nsteps</span>
        <span class="k">if</span> <span class="n">nx</span> <span class="o">-</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tolerance</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">ny</span> <span class="o">-</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">tolerance</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">nz</span> <span class="o">-</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">tolerance</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;outside&quot;</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tolerance</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">tolerance</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">tolerance</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;outside&quot;</span>

        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="n">atom_type</span><span class="p">]</span>

        <span class="n">scores</span> <span class="o">=</span> <span class="p">{</span><span class="n">g</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">di</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">dj</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="n">dk</span><span class="p">):</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">di</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">dj</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="n">dk</span><span class="p">)</span> <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span>
                  <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">tolerance</span><span class="p">,</span> <span class="o">+</span><span class="n">tolerance</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                  <span class="k">for</span> <span class="n">dj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">tolerance</span><span class="p">,</span> <span class="o">+</span><span class="n">tolerance</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">dk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">tolerance</span><span class="p">,</span> <span class="o">+</span><span class="n">tolerance</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span>

        <span class="n">score</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">scores</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">score</span> <span class="o">&lt;</span> <span class="mf">0.01</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">scores</span><span class="p">[</span><span class="n">score</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">score</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices_to_point</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_atom_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">is_donor</span> <span class="ow">and</span> <span class="n">atom</span><span class="o">.</span><span class="n">is_acceptor</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;doneptor&quot;</span>
        <span class="k">elif</span> <span class="n">atom</span><span class="o">.</span><span class="n">is_acceptor</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;acceptor&quot;</span>
        <span class="k">elif</span> <span class="n">atom</span><span class="o">.</span><span class="n">is_donor</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;donor&quot;</span>
        <span class="k">elif</span> <span class="n">atom</span><span class="o">.</span><span class="n">atomic_symbol</span> <span class="o">==</span> <span class="s2">&quot;Xe&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;dummy&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;apolar&quot;</span>

    <span class="k">def</span> <span class="nf">_update_score_dic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms_by_score</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">residue</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">atom_type</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">atoms_by_score</span><span class="p">[</span><span class="n">score</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">atom</span><span class="p">,</span> <span class="n">residue</span><span class="p">,</span> <span class="n">atom_type</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">atoms_by_score</span><span class="p">[</span><span class="n">score</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">atom</span><span class="p">,</span> <span class="n">residue</span><span class="p">,</span> <span class="n">atom_type</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">_score_protein_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Assigns a score to each protein atom. Donor scores are assigned to polar hydrogens, rather than the heavy</span>
<span class="sd">        atom. Returns a dictionary of {score:[atoms]}&#39;&#39;&#39;</span>
        <span class="n">interaction_partner_dic</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;donor&#39;</span><span class="p">:</span> <span class="s1">&#39;acceptor&#39;</span><span class="p">,</span> <span class="s1">&#39;acceptor&#39;</span><span class="p">:</span> <span class="s1">&#39;donor&#39;</span><span class="p">,</span> <span class="s1">&#39;apolar&#39;</span><span class="p">:</span> <span class="s1">&#39;apolar&#39;</span><span class="p">}</span>
        <span class="n">atoms_by_score</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">residue</span> <span class="o">=</span> <span class="s2">&quot;Blah&quot;</span>
        <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">prot</span><span class="o">.</span><span class="n">residues</span><span class="p">:</span>
            <span class="n">atom_scores</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">atomic_number</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">atom_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_atom_type</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">atom_type</span> <span class="o">==</span> <span class="s1">&#39;donor&#39;</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">neighbours</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">atomic_number</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_near_score</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">coordinates</span><span class="p">,</span> <span class="s1">&#39;acceptor&#39;</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_update_score_dic</span><span class="p">(</span><span class="n">atoms_by_score</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">residue</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">atom_type</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">atom_type</span> <span class="o">==</span> <span class="s1">&#39;doneptor&#39;</span><span class="p">:</span>
                    <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_near_score</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">coordinates</span><span class="p">,</span> <span class="s1">&#39;donor&#39;</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_update_score_dic</span><span class="p">(</span><span class="n">atoms_by_score</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">residue</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="s1">&#39;acceptor&#39;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">neighbours</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">atomic_number</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_near_score</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">coordinates</span><span class="p">,</span> <span class="s1">&#39;acceptor&#39;</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_update_score_dic</span><span class="p">(</span><span class="n">atoms_by_score</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">residue</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="s1">&#39;donor&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_near_score</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">interaction_partner_dic</span><span class="p">[</span><span class="n">atom_type</span><span class="p">],</span>
                                                 <span class="n">tolerance</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_update_score_dic</span><span class="p">(</span><span class="n">atoms_by_score</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">residue</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">atom_type</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">atoms_by_score</span>

<div class="viewcode-block" id="HotspotResults.score_protein"><a class="viewcode-back" href="../../hotspot_api.html#fragment_hotspot_maps.fragment_hotspot_maps.HotspotResults.score_protein">[docs]</a>    <span class="k">def</span> <span class="nf">score_protein</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Assigns a score to each protein atom. Donor scores are assigned to polar hydrogens, rather than the heavy</span>
<span class="sd">        atom.</span>
<span class="sd">        atom_id = &quot;{0}/{1}/{2}&quot;.format(residue.chain_identifier, residue.identifier.split(&#39;:&#39;)[1][3:],atom.label)</span>

<span class="sd">        :return: dict of {atom_id: score}</span>

<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">atom_dic</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">donor_scores</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">acceptor_scores</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">apolar_scores</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">prot</span><span class="o">.</span><span class="n">residues</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">atomic_number</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">donor</span><span class="p">,</span> <span class="n">donor_coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_near_score</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">coordinates</span><span class="p">,</span> <span class="s1">&#39;acceptor&#39;</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
                <span class="n">acceptor</span><span class="p">,</span> <span class="n">acceptor_coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_near_score</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">coordinates</span><span class="p">,</span> <span class="s1">&#39;donor&#39;</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
                <span class="n">apolar</span><span class="p">,</span> <span class="n">apolar_coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_near_score</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">coordinates</span><span class="p">,</span> <span class="s1">&#39;apolar&#39;</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
                <span class="nb">id</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">/</span><span class="si">{1}</span><span class="s2">/</span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">residue</span><span class="o">.</span><span class="n">chain_identifier</span><span class="p">,</span> <span class="n">residue</span><span class="o">.</span><span class="n">identifier</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">:],</span>
                                          <span class="n">atom</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
                <span class="n">atom_dic</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;donor&#39;</span><span class="p">:</span> <span class="n">donor</span><span class="p">,</span>
                    <span class="s1">&#39;acceptor&#39;</span><span class="p">:</span> <span class="n">acceptor</span><span class="p">,</span>
                    <span class="s1">&#39;apolar&#39;</span><span class="p">:</span> <span class="n">apolar</span><span class="p">,</span>
                    <span class="s1">&#39;residue&#39;</span><span class="p">:</span> <span class="n">residue</span><span class="p">,</span>
                    <span class="s1">&#39;donor_coord&#39;</span><span class="p">:</span> <span class="n">donor_coord</span><span class="p">,</span>
                    <span class="s1">&#39;acceptor_coord&#39;</span><span class="p">:</span> <span class="n">acceptor_coord</span><span class="p">,</span>
                    <span class="s1">&#39;apolar_coord&#39;</span><span class="p">:</span> <span class="n">apolar_coord</span><span class="p">,</span>
                <span class="p">}</span>

                <span class="k">if</span> <span class="n">donor</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">donor_scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">donor</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">acceptor</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">acceptor_scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">acceptor</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">apolar</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">apolar_scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">apolar</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">donor_scores</span> <span class="o">=</span> <span class="n">donor_scores</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acceptor_scores</span> <span class="o">=</span> <span class="n">acceptor_scores</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apolar_scores</span> <span class="o">=</span> <span class="n">apolar_scores</span>

        <span class="k">return</span> <span class="n">atom_dic</span></div>

    <span class="k">def</span> <span class="nf">_get_percentiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">percentile</span><span class="o">=</span><span class="mi">90</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">apolar_scores</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">score_protein</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">donor_percentile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">donor_scores</span><span class="p">,</span> <span class="n">percentile</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">donor_percentile</span> <span class="o">=</span> <span class="mi">14</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">acceptor_percentile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">acceptor_scores</span><span class="p">,</span> <span class="n">percentile</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">acceptor_percentile</span> <span class="o">=</span> <span class="mi">14</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">apolar_percentile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apolar_scores</span><span class="p">,</span> <span class="n">percentile</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">apolar_percentile</span> <span class="o">=</span> <span class="mi">14</span>

        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;donor&#39;</span><span class="p">:</span> <span class="n">donor_percentile</span><span class="p">,</span>
                <span class="s1">&#39;acceptor&#39;</span><span class="p">:</span> <span class="n">acceptor_percentile</span><span class="p">,</span>
                <span class="s1">&#39;apolar&#39;</span><span class="p">:</span> <span class="n">apolar_percentile</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">_get_feat_atom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
        <span class="n">ats</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">prot</span><span class="o">.</span><span class="n">atoms</span> <span class="k">if</span>
               <span class="nb">round</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="nb">round</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">round</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="nb">round</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                                                                         <span class="mi">2</span><span class="p">)]</span>
        <span class="c1"># and round(a.coordinates[2],2) == coords[2]]</span>
        <span class="k">return</span> <span class="n">ats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_get_ideal_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vector</span><span class="p">,</span> <span class="n">feature_coords</span><span class="p">,</span> <span class="n">feat_distance</span><span class="p">):</span>
        <span class="n">feat_x</span> <span class="o">=</span> <span class="n">feature_coords</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">feat_distance</span><span class="p">)</span>
        <span class="n">feat_y</span> <span class="o">=</span> <span class="n">feature_coords</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="n">vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">feat_distance</span><span class="p">)</span>
        <span class="n">feat_z</span> <span class="o">=</span> <span class="n">feature_coords</span><span class="o">.</span><span class="n">z</span> <span class="o">+</span> <span class="p">(</span><span class="n">vector</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">feat_distance</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">feat_x</span><span class="p">,</span> <span class="n">feat_y</span><span class="p">,</span> <span class="n">feat_z</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_score_cavity_features</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cav</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Assign a score to each cavity feature, based on the feature&#39;s ideal interaction point</span>

<span class="sd">        :param cav: a :class:`ccdc.Cavity.cavity` instance</span>
<span class="sd">        :return: a dictionary {score:[list of features], where each item in list of features is a tuple of (atom, feature, atom_type)</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="sd">&#39;&#39;&#39;Assigns a score to each cavity feature. Donor scores are assigned to polar hydrogens, rather than the heavy</span>
<span class="sd">            atom. Returns a dictionary of {score:[features]}&#39;&#39;&#39;</span>

        <span class="k">for</span> <span class="n">feat</span> <span class="ow">in</span> <span class="n">cav</span><span class="o">.</span><span class="n">features</span><span class="p">:</span>
            <span class="n">atom_type_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;pi&#39;</span><span class="p">:</span> <span class="s1">&#39;apolar&#39;</span><span class="p">,</span> <span class="s1">&#39;aromatic&#39;</span><span class="p">:</span> <span class="s1">&#39;apolar&#39;</span><span class="p">,</span> <span class="s1">&#39;aliphatic&#39;</span><span class="p">:</span> <span class="s1">&#39;apolar&#39;</span><span class="p">,</span> <span class="s1">&#39;donor&#39;</span><span class="p">:</span> <span class="s1">&#39;acceptor&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;acceptor&#39;</span><span class="p">:</span> <span class="s1">&#39;donor&#39;</span><span class="p">}</span>
            <span class="n">feat_coords</span> <span class="o">=</span> <span class="n">feat</span><span class="o">.</span><span class="n">coordinates</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_feat_atom</span><span class="p">(</span><span class="n">feat_coords</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">atom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">ideal_vector</span> <span class="o">=</span> <span class="n">feat</span><span class="o">.</span><span class="n">protein_vector</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_ideal_coordinates</span><span class="p">(</span><span class="n">ideal_vector</span><span class="p">,</span> <span class="n">feat_coords</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">feat</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;donor_acceptor&#39;</span><span class="p">:</span>
                <span class="n">d_score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_near_score</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="s1">&#39;acceptor&#39;</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
                <span class="n">a_score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_near_score</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="s1">&#39;donor&#39;</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_score_dic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">features_by_score</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">feat</span><span class="p">,</span> <span class="n">a_score</span><span class="p">,</span> <span class="s1">&#39;acceptor&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">neighbours</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">atomic_number</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_update_score_dic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">features_by_score</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">feat</span><span class="p">,</span> <span class="n">d_score</span><span class="p">,</span> <span class="s1">&#39;donor&#39;</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">atom_type_dict</span><span class="p">[</span><span class="n">feat</span><span class="o">.</span><span class="n">type</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;acceptor&#39;</span><span class="p">:</span>
                <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_near_score</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">atom_type_dict</span><span class="p">[</span><span class="n">feat</span><span class="o">.</span><span class="n">type</span><span class="p">],</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">neighbours</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">atomic_number</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_update_score_dic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">features_by_score</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">feat</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="s1">&#39;donor&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">atom_type_dict</span><span class="p">[</span><span class="n">feat</span><span class="o">.</span><span class="n">type</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;donor&#39;</span><span class="p">:</span>
                <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_near_score</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">atom_type_dict</span><span class="p">[</span><span class="n">feat</span><span class="o">.</span><span class="n">type</span><span class="p">],</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_score_dic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">features_by_score</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">feat</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="s1">&#39;acceptor&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">features_by_score</span>

    <span class="k">def</span> <span class="nf">_score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Calculate geometric mean of scores&#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>

<div class="viewcode-block" id="HotspotResults.score_ligand_atoms"><a class="viewcode-back" href="../../hotspot_api.html#fragment_hotspot_maps.fragment_hotspot_maps.HotspotResults.score_ligand_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">score_ligand_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="nb">dict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">schematic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Score ligand atoms in hotspot maps, taking interaction type into account.</span>

<span class="sd">        :param mol: a :class:`ccdc.Molecule` instance</span>
<span class="sd">        :param schematic: bool, catgorises score,for use with 2D depiction</span>
<span class="sd">        :param tolerance: int, the highest scoring grid point within +/- tolerance in each of the x,y and z directions will be assigned to the atom</span>
<span class="sd">        :return:</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">dict</span> <span class="o">==</span> <span class="kc">True</span> <span class="ow">or</span> <span class="n">schematic</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">scores</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scores</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">atom_labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">heavy_atoms</span><span class="p">:</span>
            <span class="n">atom_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
            <span class="n">atom_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_atom_type</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">atom_type</span> <span class="o">==</span> <span class="s1">&#39;doneptor&#39;</span><span class="p">:</span>
                <span class="n">d_score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_near_score</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">coordinates</span><span class="p">,</span> <span class="s1">&#39;donor&#39;</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">a_score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_near_score</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">coordinates</span><span class="p">,</span> <span class="s1">&#39;acceptor&#39;</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">score</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">d_score</span><span class="p">,</span> <span class="n">a_score</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">score</span><span class="p">,</span> <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_near_score</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">atom_type</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)</span>
                <span class="c1"># print(score, atom_type, atom.atomic_symbol)</span>

            <span class="k">if</span> <span class="n">schematic</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">score</span> <span class="o">&gt;=</span> <span class="mi">17</span><span class="p">:</span>
                    <span class="n">score</span> <span class="o">=</span> <span class="mi">20</span>
                <span class="k">elif</span> <span class="n">score</span> <span class="o">&lt;</span> <span class="mi">17</span> <span class="ow">and</span> <span class="n">score</span> <span class="o">&gt;=</span> <span class="mi">14</span><span class="p">:</span>
                    <span class="n">score</span> <span class="o">=</span> <span class="mi">10</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">score</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">scores</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">atom</span><span class="o">.</span><span class="n">label</span><span class="p">:</span> <span class="n">score</span><span class="p">})</span>

            <span class="k">elif</span> <span class="nb">dict</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">scores</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="nb">str</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">label</span><span class="p">):</span> <span class="n">score</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>
        <span class="c1"># return atom_labels , scores</span>
        <span class="k">return</span> <span class="n">scores</span></div>

<div class="viewcode-block" id="HotspotResults.schematic_map"><a class="viewcode-back" href="../../hotspot_api.html#fragment_hotspot_maps.fragment_hotspot_maps.HotspotResults.schematic_map">[docs]</a>    <span class="k">def</span> <span class="nf">schematic_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ligand</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s2">&quot;diagram.png&quot;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Display the distribution of scores as a heatmap on a 2D depiction of the molecule</span>

<span class="sd">        :param ligand: a :class:`ccdc.Molecule` object.</span>
<span class="sd">        :param title: str, Title placed at the top of the image</span>
<span class="sd">        :param output: str, Output file name</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">rdkit</span> <span class="k">import</span> <span class="n">Chem</span>
            <span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="k">import</span> <span class="n">Draw</span>
            <span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="k">import</span> <span class="n">AllChem</span>
            <span class="kn">from</span> <span class="nn">matplotlib.colors</span> <span class="k">import</span> <span class="n">LinearSegmentedColormap</span>

        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;rdkit is needed for this method&quot;&quot;&quot;</span><span class="p">)</span>
            <span class="n">exit</span><span class="p">()</span>

        <span class="n">mol</span> <span class="o">=</span> <span class="n">MoleculeReader</span><span class="p">(</span><span class="n">ligand</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">ligand</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;mol2&quot;</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">ligand</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">lig</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">lig</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">mol_rdkit</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromMol2Block</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">AllChem</span><span class="o">.</span><span class="n">Compute2DCoords</span><span class="p">(</span><span class="n">mol_rdkit</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">ligand</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;sdf&quot;</span><span class="p">:</span>
            <span class="n">suppl</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">SDMolSupplier</span><span class="p">(</span><span class="n">ligand</span><span class="p">)</span>
            <span class="n">mol_rdkit</span> <span class="o">=</span> <span class="n">suppl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">AllChem</span><span class="o">.</span><span class="n">Compute2DCoords</span><span class="p">(</span><span class="n">mol_rdkit</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Method supports .mol2 files only!&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span>

        <span class="n">scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">score_ligand_atoms</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">schematic</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">num_atoms</span> <span class="o">=</span> <span class="n">mol_rdkit</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">()</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mf">0.9</span> <span class="o">/</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">num_atoms</span><span class="p">))</span>
        <span class="n">s</span> <span class="o">=</span> <span class="mf">0.005</span>

        <span class="n">contribs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">scores</span><span class="p">[</span><span class="n">mol_rdkit</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">GetProp</span><span class="p">(</span><span class="s1">&#39;_TriposAtomName&#39;</span><span class="p">)])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span>
                    <span class="nb">range</span><span class="p">(</span><span class="n">mol_rdkit</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">())]</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">Draw</span><span class="o">.</span><span class="n">MolToMPL</span><span class="p">(</span><span class="n">mol_rdkit</span><span class="p">)</span>

        <span class="n">cm</span> <span class="o">=</span> <span class="n">colourmap</span><span class="p">(</span><span class="n">scheme</span><span class="o">=</span><span class="s2">&quot;inferno&quot;</span><span class="p">)</span>
        <span class="n">test_cm</span> <span class="o">=</span> <span class="n">LinearSegmentedColormap</span><span class="o">.</span><span class="n">from_list</span><span class="p">(</span><span class="vm">__file__</span><span class="p">,</span> <span class="n">cm</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">Draw</span><span class="o">.</span><span class="n">calcAtomGaussians</span><span class="p">(</span><span class="n">mol_rdkit</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">contribs</span><span class="p">)</span>

            <span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">test_cm</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;bilinear&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
                               <span class="n">extent</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">title</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">1.25</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">horizontalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">verticalalignment</span><span class="o">=</span><span class="s1">&#39;top&#39;</span><span class="p">,</span>
                     <span class="n">color</span><span class="o">=</span><span class="s2">&quot;white&quot;</span><span class="p">)</span>

        <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="HotspotResults.score_ligand"><a class="viewcode-back" href="../../hotspot_api.html#fragment_hotspot_maps.fragment_hotspot_maps.HotspotResults.score_ligand">[docs]</a>    <span class="k">def</span> <span class="nf">score_ligand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Score ligand in hotspot maps, taking interaction type into account.</span>

<span class="sd">        :param mol: a :class:`ccdc.Molecule` object</span>
<span class="sd">        :return: float, Geometric mean of atomic scores</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">score_ligand_atoms</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="nb">dict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">schematic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)</span>
        <span class="c1"># print(scores)</span>
        <span class="n">geo_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">geo_mean</span></div>

    <span class="k">def</span> <span class="nf">_get_percentage_rank</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">atom_type</span><span class="p">):</span>
        <span class="n">coordinates</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">coordinates</span>
        <span class="n">score</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_near_score</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">atom_type</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="n">atom_type</span><span class="p">]</span><span class="o">.</span><span class="n">nsteps</span>

        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="n">atom_type</span><span class="p">]</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nx</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nz</span><span class="p">)</span>
                  <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">filtered_scores</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">scores</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">score</span><span class="p">]</span>

        <span class="n">percentage_rank</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">filtered_scores</span><span class="p">))</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">scores</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">percentage_rank</span>

    <span class="k">def</span> <span class="nf">_get_ligand_percentage_rank</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the percentage rank for each atom of a ligand</span>
<span class="sd">        :param mol: a :class:`ccdc.Molecule` instance</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">percentage_ranks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">heavy_atoms</span><span class="p">:</span>
            <span class="n">atom_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_atom_type</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">atom_type</span> <span class="o">==</span> <span class="s1">&#39;doneptor&#39;</span><span class="p">:</span>
                <span class="n">atom_type</span> <span class="o">=</span> <span class="s1">&#39;donor&#39;</span>
            <span class="n">percentage_ranks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_percentage_rank</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">atom_type</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">percentage_ranks</span>

    <span class="k">def</span> <span class="nf">_get_grid_percentiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">percentiles</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        percentile of non-zero grid values</span>

<span class="sd">        :param g:</span>
<span class="sd">        :param percentiles:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">nsteps</span>
        <span class="n">percentiles_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nx</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>
                  <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">percentiles_dict</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">strength</span><span class="p">,</span> <span class="n">percentile</span> <span class="ow">in</span> <span class="n">percentiles</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">cutoff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">percentile</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.01</span>
                <span class="n">percentiles_dict</span><span class="p">[</span><span class="n">strength</span><span class="p">]</span> <span class="o">=</span> <span class="n">cutoff</span>

        <span class="k">return</span> <span class="n">percentiles_dict</span>

    <span class="k">def</span> <span class="nf">_single_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Takes all grids in the hotspot result object and applies a mask, such that for each grid point is only described</span>
<span class="sd">        by the highest scoring map. The grids are kept as separate object in order to track interaction type, however</span>
<span class="sd">        they could be summed to give a single grid</span>
<span class="sd">        :return:</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">probe</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">masked_grids</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">probe</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">other_grids</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">probe</span><span class="p">]</span>
                <span class="n">mg</span> <span class="o">=</span> <span class="n">g</span> <span class="o">*</span> <span class="p">(</span>
                        <span class="p">(</span><span class="n">g</span> <span class="o">&gt;</span> <span class="n">other_grids</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">g</span> <span class="o">&gt;</span> <span class="n">other_grids</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>  <span class="c1"># &amp; (g &gt;other_grids[2]) &amp; (g &gt;other_grids[3]))</span>
                <span class="n">masked_grids</span><span class="p">[</span><span class="n">probe</span><span class="p">]</span> <span class="o">=</span> <span class="n">mg</span>

        <span class="k">return</span> <span class="n">masked_grids</span>

    <span class="k">def</span> <span class="nf">_grid_values_in_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">r_start</span><span class="p">,</span> <span class="n">r_finish</span><span class="p">,</span> <span class="n">score_cutoff</span><span class="p">):</span>

        <span class="n">all_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">range_points</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">island</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">islands</span><span class="p">(</span><span class="n">score_cutoff</span> <span class="o">-</span> <span class="mf">0.01</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">island</span><span class="p">:</span>
            <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">nsteps</span>
            <span class="n">island_all_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nz</span><span class="p">)</span>
                                 <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">score_cutoff</span><span class="p">]</span>

            <span class="n">island_range_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                                   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nz</span><span class="p">)</span>
                                   <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">r_start</span> <span class="ow">and</span> <span class="n">g</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">r_finish</span><span class="p">]</span>

            <span class="n">all_points</span> <span class="o">+=</span> <span class="n">island_all_points</span>
            <span class="n">range_points</span> <span class="o">+=</span> <span class="n">island_range_points</span>

        <span class="n">avg_score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">all_points</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">range_points</span><span class="p">,</span> <span class="n">all_points</span><span class="p">,</span> <span class="n">avg_score</span>

    <span class="k">def</span> <span class="nf">_count_non_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">):</span>
        <span class="c1"># print(cutoff)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">tmp_g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_island_by_volume</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sg</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">9999</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">tmp_g</span><span class="o">.</span><span class="n">nsteps</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">9999</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nz</span><span class="p">)</span>
                  <span class="k">if</span> <span class="n">tmp_g</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">cutoff</span><span class="p">]</span>

        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_gp</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_count_non_zero_alt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">cutoff</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">tmp_g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_island_by_volume</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sg</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">999999</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">tmp_g</span><span class="o">.</span><span class="n">nsteps</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">points</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nz</span><span class="p">)</span>
                  <span class="k">if</span> <span class="n">tmp_g</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">cutoff</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_gp</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_island_by_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">score_cutoff</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        :param sg:</span>
<span class="sd">        :param volume:</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">island</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">islands</span><span class="p">(</span><span class="n">score_cutoff</span><span class="p">)</span>
        <span class="n">island_by_total</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">island</span><span class="p">:</span>
            <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">nsteps</span>
            <span class="n">island_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                             <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nz</span><span class="p">)</span>
                             <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">score_cutoff</span><span class="p">]</span>
            <span class="n">total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">island_points</span><span class="p">)</span>
            <span class="n">island_by_total</span><span class="p">[</span><span class="n">total</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">top_score</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">island_by_total</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">tmp_g</span> <span class="o">=</span> <span class="n">island_by_total</span><span class="p">[</span><span class="n">top_score</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">tmp_g</span>

    <span class="k">def</span> <span class="nf">_get_grid_by_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">volume</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Takes a single grid input (produced by _single_grid()) and produces a mask that will provide a grid with the</span>
<span class="sd">        desired volume</span>
<span class="sd">        :param sg:</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># Calculate number of grid points that corresponds to selected volume</span>
        <span class="n">num_gp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span> <span class="o">/</span> <span class="mf">0.125</span><span class="p">)</span>
        <span class="n">all_points</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_crystal_contacts</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_gp</span> <span class="o">=</span> <span class="n">num_gp</span>

        <span class="c1"># Find the largest island at score_cutoff</span>
        <span class="n">score_cutoff</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">fminbound</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_count_non_zero</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="n">xtol</span><span class="o">=</span><span class="mf">0.025</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_count_non_zero_alt</span><span class="p">(</span><span class="n">score_cutoff</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">score_cutoff</span> <span class="o">-=</span> <span class="mf">0.025</span>
        <span class="k">if</span> <span class="n">score_cutoff</span> <span class="o">&gt;=</span> <span class="mi">29</span><span class="p">:</span>
            <span class="n">score_cutoff</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># print(score_cutoff)</span>

        <span class="n">tmp_g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_island_by_volume</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sg</span><span class="p">,</span> <span class="n">score_cutoff</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">tmp_g</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tmp_g</span> <span class="o">=</span> <span class="n">sg</span> <span class="o">*</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="n">tmp_g</span>
        <span class="n">c_sg</span><span class="p">,</span> <span class="n">top_g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_common_grid</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">tmp_g</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">tmp_g</span><span class="o">.</span><span class="n">nsteps</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nz</span><span class="p">):</span>
                    <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices_to_point</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">tmp_g</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">all_points</span><span class="p">[</span><span class="n">c_sg</span><span class="o">.</span><span class="n">value_at_point</span><span class="p">(</span><span class="n">coords</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="n">all_points</span><span class="p">[</span><span class="n">c_sg</span><span class="o">.</span><span class="n">value_at_point</span><span class="p">(</span><span class="n">coords</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="n">coords</span><span class="p">]</span>

        <span class="n">scores</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">all_points</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">kept_points</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">score</span> <span class="ow">in</span> <span class="n">scores</span><span class="p">:</span>
            <span class="n">kept_points</span> <span class="o">+=</span> <span class="n">all_points</span><span class="p">[</span><span class="n">score</span><span class="p">]</span>
            <span class="n">new_cutoff</span> <span class="o">=</span> <span class="n">score</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kept_points</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">num_gp</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cutoff&quot;</span><span class="p">,</span> <span class="n">new_cutoff</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">top_g</span> <span class="o">&gt;</span> <span class="n">new_cutoff</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mask</span>

    <span class="k">def</span> <span class="nf">_percent_in_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">r_start</span><span class="p">,</span> <span class="n">r_finish</span><span class="p">,</span> <span class="n">score_cutoff</span><span class="p">):</span>

        <span class="n">range_points</span><span class="p">,</span> <span class="n">all_points</span><span class="p">,</span> <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_values_in_range</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">r_start</span><span class="p">,</span> <span class="n">r_finish</span><span class="p">,</span> <span class="n">score_cutoff</span><span class="p">)</span>

        <span class="n">num_all</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_points</span><span class="p">))</span>
        <span class="n">num_range</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">range_points</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">num_all</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">num_range</span> <span class="o">/</span> <span class="n">num_all</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>

    <span class="k">def</span> <span class="nf">_percent_by_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid_dict</span><span class="p">):</span>

        <span class="n">all_g</span> <span class="o">=</span> <span class="n">grid_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="n">sum_g</span> <span class="o">=</span> <span class="n">all_g</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">all_g</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">sum_g</span> <span class="o">+=</span> <span class="n">g</span>
        <span class="n">combined_range_points</span><span class="p">,</span> <span class="n">combined_all_points</span><span class="p">,</span> <span class="n">avg_score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_values_in_range</span><span class="p">(</span><span class="n">sum_g</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10000</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">percent_by_type</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">percent_by_type</span><span class="p">[</span><span class="s1">&#39;average&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">avg_score</span>
        <span class="n">percent_by_type</span><span class="p">[</span><span class="s1">&#39;volume&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">combined_all_points</span><span class="p">))</span> <span class="o">*</span> <span class="mf">0.125</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">percent_by_type</span><span class="p">[</span><span class="s1">&#39;volume&#39;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">probe</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grid_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="n">range_points</span><span class="p">,</span> <span class="n">all_points</span><span class="p">,</span> <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_values_in_range</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10000</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">combined_all_points</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_points</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">combined_range_points</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">range_points</span><span class="p">))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_points</span><span class="p">))</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">combined_all_points</span><span class="p">)))</span> <span class="o">*</span> <span class="mi">100</span>
            <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">percent_by_type</span><span class="p">[</span><span class="n">probe</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>

        <span class="k">return</span> <span class="n">percent_by_type</span>

<div class="viewcode-block" id="HotspotResults.output_extracted_hotspots"><a class="viewcode-back" href="../../hotspot_api.html#fragment_hotspot_maps.fragment_hotspot_maps.HotspotResults.output_extracted_hotspots">[docs]</a>    <span class="k">def</span> <span class="nf">output_extracted_hotspots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">out_dir</span><span class="p">,</span> <span class="n">fragments</span><span class="p">,</span> <span class="n">lead</span><span class="p">,</span> <span class="n">charged</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        in development</span>

<span class="sd">        :return: str, script to visualise hotspots</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out_dir</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out_dir</span> <span class="o">=</span> <span class="n">getcwd</span><span class="p">()</span>
        <span class="nb">str</span> <span class="o">=</span> <span class="n">extracted_hotspot_template</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">charged</span><span class="p">,</span> <span class="n">fragments</span><span class="p">,</span> <span class="n">lead</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">(</span><span class="n">out_dir</span><span class="p">):</span>
            <span class="n">mkdir</span><span class="p">(</span><span class="n">out_dir</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="s2">&quot;extracted_hotspots.py&quot;</span><span class="p">),</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
            <span class="n">w</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">MoleculeWriter</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="s2">&quot;protein.pdb&quot;</span><span class="p">))</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
            <span class="n">w</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prot</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_get_large_cavity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buriedness</span><span class="p">,</span> <span class="n">drug_volume</span><span class="o">=</span><span class="mi">300</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        return cavities over a threshold size (volume approximately the volume of an average drug)</span>

<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">large</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">island</span> <span class="ow">in</span> <span class="n">buriedness</span><span class="o">.</span><span class="n">islands</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">island</span><span class="o">.</span><span class="n">nsteps</span>
            <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">island</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">)</span> <span class="k">for</span> <span class="n">nx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">ny</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">nz</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">island</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.125</span>
            <span class="k">if</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">drug_volume</span><span class="p">:</span>
                <span class="n">large</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">island</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">large</span>

<div class="viewcode-block" id="HotspotResults.drug_sized"><a class="viewcode-back" href="../../hotspot_api.html#fragment_hotspot_maps.fragment_hotspot_maps.HotspotResults.drug_sized">[docs]</a>    <span class="k">def</span> <span class="nf">drug_sized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buriedness</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        detemines whether a hotspot resides within a region that can accomodate a drug sized molecule</span>

<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">bottom_left</span><span class="p">,</span> <span class="n">top_right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="s2">&quot;apolar&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">bounding_box</span>
        <span class="n">centroid</span> <span class="o">=</span> <span class="n">molecule</span><span class="o">.</span><span class="n">Coordinates</span><span class="p">(((</span><span class="n">bottom_left</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">top_right</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
                                        <span class="p">((</span><span class="n">bottom_left</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">top_right</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
                                        <span class="p">((</span><span class="n">bottom_left</span><span class="o">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">top_right</span><span class="o">.</span><span class="n">z</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
                                        <span class="p">)</span>
        <span class="n">drug_cavity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_large_cavity</span><span class="p">(</span><span class="n">buriedness</span><span class="o">=</span><span class="n">buriedness</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">drug_cavity</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains_point</span><span class="p">(</span><span class="n">centroid</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="HotspotResults.hotspot_score"><a class="viewcode-back" href="../../hotspot_api.html#fragment_hotspot_maps.fragment_hotspot_maps.HotspotResults.hotspot_score">[docs]</a>    <span class="k">def</span> <span class="nf">hotspot_score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        caution! only use for extracted hotspots!</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">total</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_score</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">probe</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                 <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_score</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_score</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="s2">&quot;apolar&quot;</span><span class="p">],</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="HotspotResults.get_bfactors"><a class="viewcode-back" href="../../hotspot_api.html#fragment_hotspot_maps.fragment_hotspot_maps.HotspotResults.get_bfactors">[docs]</a>    <span class="k">def</span> <span class="nf">get_bfactors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pdb_file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assign B factors</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lines_from_file</span><span class="p">(</span><span class="n">pdb_file</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">21</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;:&quot;</span> <span class="o">+</span> <span class="n">l</span><span class="p">[</span><span class="mi">17</span><span class="p">:</span><span class="mi">20</span><span class="p">]</span> <span class="o">+</span> <span class="n">l</span><span class="p">[</span><span class="mi">23</span><span class="p">:</span><span class="mi">26</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">l</span><span class="p">[</span><span class="mi">12</span><span class="p">:</span><span class="mi">16</span><span class="p">])</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">):</span> <span class="nb">float</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">60</span><span class="p">:</span><span class="mi">66</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span> <span class="o">==</span> <span class="s2">&quot;ATOM&quot;</span><span class="p">}</span></div>

<div class="viewcode-block" id="HotspotResults.hotspot_bfactor"><a class="viewcode-back" href="../../hotspot_api.html#fragment_hotspot_maps.fragment_hotspot_maps.HotspotResults.hotspot_bfactor">[docs]</a>    <span class="k">def</span> <span class="nf">hotspot_bfactor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pdb_file</span><span class="p">,</span> <span class="n">bfactor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        :param prot:</span>
<span class="sd">        :param bfactor:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prot</span> <span class="o">=</span> <span class="n">Protein</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">pdb_file</span><span class="p">)</span>
        <span class="n">prot</span><span class="o">.</span><span class="n">remove_all_metals</span><span class="p">()</span>
        <span class="n">prot</span><span class="o">.</span><span class="n">remove_all_waters</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">lig</span> <span class="ow">in</span> <span class="n">prot</span><span class="o">.</span><span class="n">ligands</span><span class="p">:</span>
            <span class="n">prot</span><span class="o">.</span><span class="n">remove_ligand</span><span class="p">(</span><span class="n">lig</span><span class="o">.</span><span class="n">identifier</span><span class="p">)</span>

        <span class="n">mini</span><span class="p">,</span> <span class="n">maxi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="s2">&quot;apolar&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">bounding_box</span>
        <span class="n">centroid</span> <span class="o">=</span> <span class="n">molecule</span><span class="o">.</span><span class="n">Coordinates</span><span class="p">((</span><span class="n">mini</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">maxi</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">mini</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">maxi</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">mini</span><span class="o">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">maxi</span><span class="o">.</span><span class="n">z</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">bs</span> <span class="o">=</span> <span class="n">prot</span><span class="o">.</span><span class="n">BindingSiteFromPoint</span><span class="p">(</span><span class="n">protein</span><span class="o">=</span><span class="n">prot</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">centroid</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
        <span class="n">residues</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">identifier</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">bs</span><span class="o">.</span><span class="n">residues</span><span class="p">]</span>
        <span class="n">protein</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">identifier</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">prot</span><span class="o">.</span><span class="n">residues</span><span class="p">]</span>
        <span class="n">deletes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">protein</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">residues</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">delete</span> <span class="ow">in</span> <span class="n">deletes</span><span class="p">:</span>
            <span class="n">prot</span><span class="o">.</span><span class="n">remove_residue</span><span class="p">(</span><span class="n">delete</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="n">bfactor</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">identifier</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="p">)]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">prot</span><span class="o">.</span><span class="n">residues</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">atoms</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prot</span> <span class="o">=</span> <span class="n">prot</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></div>

<div class="viewcode-block" id="HotspotResults.output_data"><a class="viewcode-back" href="../../hotspot_api.html#fragment_hotspot_maps.fragment_hotspot_maps.HotspotResults.output_data">[docs]</a>    <span class="k">def</span> <span class="nf">output_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hr</span><span class="p">,</span> <span class="n">buriedness</span><span class="p">,</span> <span class="n">pdb_file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param hr:</span>
<span class="sd">        :return:</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">identifier</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">donor</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">acceptor</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">negative</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">positive</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">drug_sized</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">apolar_score</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">hotspot_score</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">bfactor_mean</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">bfactor_median</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">hotspot_bfactor_mean</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">hotspot_bfactor_median</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">bfactor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bfactors</span><span class="p">(</span><span class="n">pdb_file</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hr</span><span class="p">):</span>
            <span class="n">composition</span> <span class="o">=</span> <span class="p">{</span><span class="n">probe</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">islands</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="mi">14</span><span class="p">))</span> <span class="k">for</span> <span class="n">probe</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">h</span><span class="o">.</span><span class="n">super_grids</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="n">identifier</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">donor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">composition</span><span class="p">[</span><span class="s2">&quot;donor&quot;</span><span class="p">])</span>
            <span class="n">acceptor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">composition</span><span class="p">[</span><span class="s2">&quot;acceptor&quot;</span><span class="p">])</span>
            <span class="n">negative</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">composition</span><span class="p">[</span><span class="s2">&quot;negative&quot;</span><span class="p">])</span>
            <span class="n">positive</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">composition</span><span class="p">[</span><span class="s2">&quot;positive&quot;</span><span class="p">])</span>
            <span class="n">drug_sized</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">drug_sized</span><span class="p">(</span><span class="n">buriedness</span><span class="p">))</span>
            <span class="n">apolar_score</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">hotspot_score</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
            <span class="n">hotspot_score</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">hotspot_score</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="n">bfactor_mean</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">bfactor</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
            <span class="n">bfactor_median</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">bfactor</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="mi">50</span><span class="p">))</span>
            <span class="n">mean</span><span class="p">,</span> <span class="n">median</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">hotspot_bfactor</span><span class="p">(</span><span class="n">pdb_file</span><span class="p">,</span> <span class="n">bfactor</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pdb_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">hotspot_bfactor_mean</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mean</span><span class="p">)</span>
                <span class="n">hotspot_bfactor_median</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">median</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;identifier&quot;</span><span class="p">:</span> <span class="n">identifier</span><span class="p">,</span> <span class="s2">&quot;donor&quot;</span><span class="p">:</span> <span class="n">donor</span><span class="p">,</span> <span class="s2">&quot;acceptor&quot;</span><span class="p">:</span> <span class="n">acceptor</span><span class="p">,</span> <span class="s2">&quot;negative&quot;</span><span class="p">:</span> <span class="n">negative</span><span class="p">,</span>
                             <span class="s2">&quot;positive&quot;</span><span class="p">:</span> <span class="n">positive</span><span class="p">,</span> <span class="s2">&quot;drug_sized_cavity&quot;</span><span class="p">:</span> <span class="n">drug_sized</span><span class="p">,</span> <span class="s2">&quot;apolar_av_score&quot;</span><span class="p">:</span> <span class="n">apolar_score</span><span class="p">,</span>
                             <span class="s2">&quot;average_score&quot;</span><span class="p">:</span> <span class="n">hotspot_score</span><span class="p">,</span> <span class="s2">&quot;bf_mean&quot;</span><span class="p">:</span> <span class="n">bfactor_mean</span><span class="p">,</span> <span class="s2">&quot;bf_median&quot;</span><span class="p">:</span> <span class="n">bfactor_median</span><span class="p">,</span>
                             <span class="s2">&quot;hbf_mean&quot;</span><span class="p">:</span> <span class="n">hotspot_bfactor_mean</span><span class="p">,</span> <span class="s2">&quot;hbf_median&quot;</span><span class="p">:</span> <span class="n">hotspot_bfactor_median</span>
                             <span class="p">})</span></div>

<div class="viewcode-block" id="HotspotResults.extract_hotspots"><a class="viewcode-back" href="../../hotspot_api.html#fragment_hotspot_maps.fragment_hotspot_maps.HotspotResults.extract_hotspots">[docs]</a>    <span class="k">def</span> <span class="nf">extract_hotspots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fragments</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lead</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bfactors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For a given output volume, hotspots are identified by the peaks in apolar propensity.</span>

<span class="sd">        :param out_dir:</span>
<span class="sd">        :param sigma: float, target volume to be selected in Angstroms^3</span>
<span class="sd">        :param cutoff: int, threshold value to contour islands</span>
<span class="sd">        :param volume: int, volume of the desired output hotspots.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">hr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">build</span> <span class="o">=</span> <span class="n">_HotspotBuilder</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># build.settings.cutoff -= 1</span>

        <span class="n">build</span><span class="o">.</span><span class="n">prot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prot</span>
        <span class="n">build</span><span class="o">.</span><span class="n">fname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fname</span>
        <span class="n">build</span><span class="o">.</span><span class="n">sampled_probes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampled_probes</span>
        <span class="n">build</span><span class="o">.</span><span class="n">super_grids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span>

        <span class="n">build</span><span class="o">.</span><span class="n">apolar_islands</span> <span class="o">=</span> <span class="n">build</span><span class="o">.</span><span class="n">get_apolar</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;apolar&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">build</span><span class="o">.</span><span class="n">apolar_islands</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">build</span><span class="o">.</span><span class="n">apolar_islands</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">g</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Z:/original/out/grid_</span><span class="si">{}</span><span class="s2">.grd&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">probe</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">build</span><span class="o">.</span><span class="n">super_grids</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">probe</span> <span class="o">==</span> <span class="s2">&quot;apolar&quot;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">build</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="n">probe</span><span class="p">]</span> <span class="o">=</span> <span class="n">build</span><span class="o">.</span><span class="n">_run_gaussian</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="n">build</span><span class="o">.</span><span class="n">polar_islands</span> <span class="o">=</span> <span class="p">{</span><span class="n">probe</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="n">probe</span><span class="p">]</span><span class="o">.</span><span class="n">islands</span><span class="p">(</span><span class="n">build</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">cutoff</span><span class="p">)</span>
                               <span class="k">for</span> <span class="n">probe</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">probe</span> <span class="o">!=</span> <span class="s2">&quot;apolar&quot;</span><span class="p">}</span>

        <span class="n">build</span><span class="o">.</span><span class="n">construct_hotspot</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">identity</span><span class="p">,</span> <span class="n">grid</span> <span class="ow">in</span> <span class="n">build</span><span class="o">.</span><span class="n">apolar_islands</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">build</span><span class="o">.</span><span class="n">donor_id</span><span class="p">[</span><span class="n">identity</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">donor</span> <span class="o">=</span> <span class="n">Grid</span><span class="o">.</span><span class="n">super_grid</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">build</span><span class="o">.</span><span class="n">donor_id</span><span class="p">[</span><span class="n">identity</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">donor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy_and_clear</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">build</span><span class="o">.</span><span class="n">acceptor_id</span><span class="p">[</span><span class="n">identity</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">acceptor</span> <span class="o">=</span> <span class="n">Grid</span><span class="o">.</span><span class="n">super_grid</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">build</span><span class="o">.</span><span class="n">acceptor_id</span><span class="p">[</span><span class="n">identity</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">acceptor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy_and_clear</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">build</span><span class="o">.</span><span class="n">positive_id</span><span class="p">[</span><span class="n">identity</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">positive</span> <span class="o">=</span> <span class="n">Grid</span><span class="o">.</span><span class="n">super_grid</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">build</span><span class="o">.</span><span class="n">positive_id</span><span class="p">[</span><span class="n">identity</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">positive</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy_and_clear</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">build</span><span class="o">.</span><span class="n">negative_id</span><span class="p">[</span><span class="n">identity</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">negative</span> <span class="o">=</span> <span class="n">Grid</span><span class="o">.</span><span class="n">super_grid</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">build</span><span class="o">.</span><span class="n">negative_id</span><span class="p">[</span><span class="n">identity</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">negative</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy_and_clear</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

            <span class="n">positive</span> <span class="o">=</span> <span class="n">build</span><span class="o">.</span><span class="n">deduplicate</span><span class="p">(</span><span class="n">donor</span><span class="p">,</span> <span class="n">positive</span><span class="p">)</span>
            <span class="n">negative</span> <span class="o">=</span> <span class="n">build</span><span class="o">.</span><span class="n">deduplicate</span><span class="p">(</span><span class="n">acceptor</span><span class="p">,</span> <span class="n">negative</span><span class="p">)</span>

            <span class="n">grd_dic</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;apolar&quot;</span><span class="p">:</span> <span class="n">grid</span><span class="p">,</span> <span class="s2">&quot;donor&quot;</span><span class="p">:</span> <span class="n">donor</span><span class="p">,</span> <span class="s2">&quot;acceptor&quot;</span><span class="p">:</span> <span class="n">acceptor</span><span class="p">,</span>
                       <span class="s2">&quot;negative&quot;</span><span class="p">:</span> <span class="n">negative</span><span class="p">,</span> <span class="s2">&quot;positive&quot;</span><span class="p">:</span> <span class="n">positive</span><span class="p">}</span>

            <span class="n">hr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Hotspots</span><span class="o">.</span><span class="n">HotspotResults</span><span class="p">(</span><span class="n">grid_dict</span><span class="o">=</span><span class="n">grd_dic</span><span class="p">,</span> <span class="n">protein</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prot</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fname</span><span class="p">,</span>
                                              <span class="n">sampled_probes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">buriedness</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out_dir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">out_dir</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_extracted_hotspots</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hr</span><span class="p">),</span> <span class="n">out_dir</span><span class="p">,</span> <span class="n">fragments</span><span class="p">,</span> <span class="n">lead</span><span class="p">,</span> <span class="n">charged</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_data</span><span class="p">(</span><span class="n">hr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">buriedness</span><span class="p">,</span> <span class="n">bfactors</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="s2">&quot;data.csv&quot;</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">hr</span></div>

<div class="viewcode-block" id="HotspotResults.best_continuous_volume"><a class="viewcode-back" href="../../hotspot_api.html#fragment_hotspot_maps.fragment_hotspot_maps.HotspotResults.best_continuous_volume">[docs]</a>    <span class="k">def</span> <span class="nf">best_continuous_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">pocket_mask</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Selects the highest scoring continuous region of propensity across all map types, matching the input volume.</span>
<span class="sd">        Selecting a molecular volume corresponding to a typical drug-like molecule (350-550 Angstroms ^3) provides a</span>
<span class="sd">        prediction of the most tractable binding site on the protein.</span>

<span class="sd">        :param volume: float, target volume to be selected in Angstroms^3</span>
<span class="sd">        :param pocket_mask: a :class:`ccdc.interaction.Grid` instance with a value of 1 at any grid points to be ignored, otherwise 0.</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">processed_grids</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># print(&quot;start descriptors&quot;)</span>

        <span class="n">masked_grids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single_grid</span><span class="p">()</span>
        <span class="n">all_g</span> <span class="o">=</span> <span class="n">masked_grids</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="n">sum_g</span> <span class="o">=</span> <span class="n">all_g</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">all_g</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">sum_g</span> <span class="o">+=</span> <span class="n">g</span>

        <span class="k">if</span> <span class="n">pocket_mask</span><span class="p">:</span>
            <span class="n">com_sum_grid</span><span class="p">,</span> <span class="n">com_pocket_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_common_grid</span><span class="p">(</span><span class="n">sum_g</span><span class="p">,</span> <span class="n">pocket_mask</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">sum_g</span> <span class="o">=</span> <span class="n">com_sum_grid</span> <span class="o">*</span> <span class="p">(</span><span class="n">com_pocket_mask</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">second_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_grid_by_volume</span><span class="p">(</span><span class="n">sum_g</span><span class="p">,</span> <span class="n">volume</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">probe</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="p">)</span>
            <span class="n">mg</span> <span class="o">=</span> <span class="n">masked_grids</span><span class="p">[</span><span class="n">probe</span><span class="p">]</span>
            <span class="n">c_mg</span><span class="p">,</span> <span class="n">c_second_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_common_grid</span><span class="p">(</span><span class="n">mg</span><span class="p">,</span> <span class="n">second_mask</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">out_g</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_mg</span> <span class="o">*</span> <span class="n">c_second_mask</span><span class="p">)</span>

            <span class="k">del</span> <span class="p">(</span><span class="n">c_mg</span><span class="p">)</span>
            <span class="k">del</span> <span class="p">(</span><span class="n">c_second_mask</span><span class="p">)</span>

            <span class="c1"># out_g.write(&#39;processed_{}.grd&#39;.format(probe))</span>
            <span class="n">processed_grids</span><span class="p">[</span><span class="n">probe</span><span class="p">]</span> <span class="o">=</span> <span class="n">out_g</span>

        <span class="n">bcv_hr</span> <span class="o">=</span> <span class="n">Hotspots</span><span class="o">.</span><span class="n">HotspotResults</span><span class="p">(</span><span class="n">processed_grids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fname</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out_dir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">out_dir</span><span class="p">)</span>

        <span class="n">remaining</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">probe</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">diff_g</span> <span class="o">=</span> <span class="n">g</span> <span class="o">-</span> <span class="n">bcv_hr</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="n">probe</span><span class="p">]</span>
            <span class="n">remaining</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">probe</span><span class="p">:</span> <span class="n">diff_g</span><span class="p">})</span>

        <span class="n">remaining_hr</span> <span class="o">=</span> <span class="n">Hotspots</span><span class="o">.</span><span class="n">HotspotResults</span><span class="p">(</span><span class="n">remaining</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fname</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out_dir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">out_dir</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">bcv_hr</span><span class="p">,</span> <span class="n">remaining_hr</span></div>

<div class="viewcode-block" id="HotspotResults.extract_pocket"><a class="viewcode-back" href="../../hotspot_api.html#fragment_hotspot_maps.fragment_hotspot_maps.HotspotResults.extract_pocket">[docs]</a>    <span class="k">def</span> <span class="nf">extract_pocket</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">whole_residues</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Create a :class:`ccdc.Protein` containing atoms or residues that have a score</span>

<span class="sd">        :param whole_residues: bool, whether to include all residue atoms if only a subset have a score &gt; 0</span>
<span class="sd">        :return: a :class:`ccdc.Protein` instance</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">prot_scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">score_protein</span><span class="p">()</span>
        <span class="n">pocket</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prot</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">pocket</span><span class="o">.</span><span class="n">remove_hydrogens</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">pocket</span><span class="o">.</span><span class="n">residues</span><span class="p">:</span>
            <span class="n">keep_residue</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
                <span class="c1"># if atom.atomic_number == 1:</span>
                <span class="c1">#     continue</span>
                <span class="n">a_id</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">/</span><span class="si">{1}</span><span class="s2">/</span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">residue</span><span class="o">.</span><span class="n">chain_identifier</span><span class="p">,</span> <span class="n">residue</span><span class="o">.</span><span class="n">identifier</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">:],</span>
                                            <span class="n">atom</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
                <span class="n">atom_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_atom_type</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">atom_type</span> <span class="o">==</span> <span class="s1">&#39;doneptor&#39;</span><span class="p">:</span>
                    <span class="n">score</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">prot_scores</span><span class="p">[</span><span class="n">a_id</span><span class="p">][</span><span class="s1">&#39;donor&#39;</span><span class="p">],</span> <span class="n">prot_scores</span><span class="p">[</span><span class="n">a_id</span><span class="p">][</span><span class="s1">&#39;acceptor&#39;</span><span class="p">]])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">score</span> <span class="o">=</span> <span class="n">prot_scores</span><span class="p">[</span><span class="n">a_id</span><span class="p">][</span><span class="n">atom_type</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">score</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">keep_residue</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="n">score</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">whole_residues</span><span class="p">:</span>
                    <span class="n">pocket</span><span class="o">.</span><span class="n">remove_atom</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">whole_residues</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">keep_residue</span><span class="p">:</span>
                <span class="n">pocket</span><span class="o">.</span><span class="n">remove_atoms</span><span class="p">(</span><span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pocket</span></div>

<div class="viewcode-block" id="HotspotResults.output_pymol_file"><a class="viewcode-back" href="../../hotspot_api.html#fragment_hotspot_maps.fragment_hotspot_maps.HotspotResults.output_pymol_file">[docs]</a>    <span class="k">def</span> <span class="nf">output_pymol_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prot_file</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Output a python script to be run from within pymol to visualise output</span>

<span class="sd">        :param prot_file: str, path to directory where output files can be saved</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">prot_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">MoleculeWriter</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/protein.pdb&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_dir</span><span class="p">))</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
                    <span class="n">w</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prot</span><span class="p">)</span>
                    <span class="n">prot_file</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/protein.pdb&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_dir</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">prot_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fname</span>
        <span class="n">percentiles</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;low&#39;</span><span class="p">:</span> <span class="mi">30</span><span class="p">}</span>
        <span class="n">cutoff_by_probe</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">probe</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">cutoff_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_grid_percentiles</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">percentiles</span><span class="p">)</span>

            <span class="n">cutoff_by_probe</span><span class="p">[</span><span class="n">probe</span><span class="p">]</span> <span class="o">=</span> <span class="n">cutoff_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">probe</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">g</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">/</span><span class="si">{1}</span><span class="s1">.grd&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_dir</span><span class="p">,</span> <span class="n">probe</span><span class="p">))</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/pymol_results_file.py&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_dir</span><span class="p">),</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">pymol_file</span><span class="p">:</span>
            <span class="n">pymol_out</span> <span class="o">=</span> <span class="n">pymol_template</span><span class="p">(</span><span class="n">prot_file</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">cutoff_by_probe</span><span class="p">)</span>
            <span class="n">pymol_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">pymol_out</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">MoleculeWriter</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_dir</span><span class="p">,</span> <span class="s2">&quot;protein.pdb&quot;</span><span class="p">))</span> <span class="k">as</span> <span class="n">writer</span><span class="p">:</span>
            <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prot</span><span class="p">)</span></div></div>



<div class="viewcode-block" id="Hotspots"><a class="viewcode-back" href="../../hotspot_api.html#fragment_hotspot_maps.fragment_hotspot_maps.Hotspots">[docs]</a><span class="k">class</span> <span class="nc">Hotspots</span><span class="p">(</span><span class="n">_HotspotsHelper</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for running Fragment Hotspot Map calculations</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">class</span> <span class="nc">_Sampler</span><span class="p">(</span><span class="n">_HotspotsHelper</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Samples one or more grids with a probe molecule</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">class</span> <span class="nc">Settings</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Settings for the sampler</span>
<span class="sd">                nrotations:                   number of rotations (keep it below 10**6)</span>
<span class="sd">                apolar_translation_threshold: translate probe to grid points above this threshold. Give lower values for</span>
<span class="sd">                                              greater sampling. Default 15</span>
<span class="sd">                polar_translation_threshold:  translate probe to grid points above this threshold. Give lower values for</span>
<span class="sd">                                              greater sampling. Default 15</span>
<span class="sd">                polar_contributions:          allow carbon atoms of probes with polar atoms to contribute to the apolar</span>
<span class="sd">                                              output map.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">nrotations</span> <span class="o">=</span> <span class="mi">3000</span>
            <span class="n">apolar_translation_threshold</span> <span class="o">=</span> <span class="mi">15</span>
            <span class="n">polar_translation_threshold</span> <span class="o">=</span> <span class="mi">15</span>
            <span class="n">polar_contributions</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">grids</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Settings used to run fragment-hotspot-maps script</span>

<span class="sd">            :param grids: list, list of :class: `ccdc.utilities.Grid` instances</span>
<span class="sd">            :param kw: &#39;settings&#39;</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">grids</span> <span class="o">=</span> <span class="n">grids</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid_dic</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">grid_dic</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span>
            <span class="n">settings</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;settings&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">settings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Settings</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="n">settings</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">probe_grids</span> <span class="o">=</span> <span class="p">[</span><span class="n">_SampleGrid</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy_and_clear</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">grid</span><span class="p">),</span> <span class="n">g</span><span class="o">.</span><span class="n">atom_predicate</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grids</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">get_priority_atom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">molecule</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Select priority atom. Select polar atom. If multiple polar atoms, select the one furthest from the centre of</span>
<span class="sd">            geometry. If no polar atoms, select atom furthest from centre of geometry</span>

<span class="sd">            :param molecule: a :class: `ccdc.molecule.Molecule` instance</span>
<span class="sd">            :return: a :class: `ccdc.molecule.Molecule` instance, str atom type</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">c</span> <span class="o">=</span> <span class="n">molecule</span><span class="o">.</span><span class="n">centre_of_geometry</span><span class="p">()</span>
            <span class="n">polar_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">molecule</span><span class="o">.</span><span class="n">atoms</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_donor</span> <span class="ow">or</span> <span class="n">a</span><span class="o">.</span><span class="n">is_acceptor</span><span class="p">]</span>
            <span class="n">atom_by_distance</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">polar_atoms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">polar_atoms</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_distance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">coordinates</span><span class="p">)</span>
                    <span class="n">atom_by_distance</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">molecule</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_distance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">coordinates</span><span class="p">)</span>
                    <span class="n">atom_by_distance</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>

            <span class="n">greatest_distance</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">atom_by_distance</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">priority_atom</span> <span class="o">=</span> <span class="n">atom_by_distance</span><span class="p">[</span><span class="n">greatest_distance</span><span class="p">]</span>

            <span class="n">pa_type</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">priority_atom</span><span class="o">.</span><span class="n">formal_charge</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">priority_atom</span><span class="o">.</span><span class="n">formal_charge</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">pa_type</span> <span class="o">=</span> <span class="s2">&quot;negative&quot;</span>
                <span class="k">elif</span> <span class="n">priority_atom</span><span class="o">.</span><span class="n">formal_charge</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">pa_type</span> <span class="o">=</span> <span class="s2">&quot;positive&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">priority_atom</span><span class="o">.</span><span class="n">is_acceptor</span><span class="p">:</span>
                    <span class="n">pa_type</span> <span class="o">=</span> <span class="s2">&quot;acceptor&quot;</span>
                <span class="k">elif</span> <span class="n">priority_atom</span><span class="o">.</span><span class="n">is_donor</span><span class="p">:</span>
                    <span class="n">pa_type</span> <span class="o">=</span> <span class="s2">&quot;donor&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pa_type</span> <span class="o">=</span> <span class="s2">&quot;apolar&quot;</span>

            <span class="k">return</span> <span class="n">priority_atom</span><span class="p">,</span> <span class="n">pa_type</span>

        <span class="k">def</span> <span class="nf">get_translation_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">priority_atom_type</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            returns a list of coordinates that are greater than the threshold, that the probe will be translated to</span>

<span class="sd">            :param priority_atom_type: str, atomic interaction type</span>
<span class="sd">            :return: list, list of :class: `ccdc.molecule.Molecule` instances</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">translate_probe</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">wg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_dic</span><span class="p">[</span><span class="n">priority_atom_type</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">priority_atom_type</span> <span class="o">==</span> <span class="s1">&#39;apolar&#39;</span><span class="p">:</span>
                <span class="n">translation_threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">apolar_translation_threshold</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">translation_threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">polar_translation_threshold</span>
            <span class="n">hs</span> <span class="o">=</span> <span class="n">wg</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">islands</span><span class="p">(</span><span class="n">translation_threshold</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">hs</span><span class="p">:</span>
                <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">nsteps</span>

                <span class="n">maxima</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_indices_to_point</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
                          <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nz</span><span class="p">)</span>
                          <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">translation_threshold</span><span class="p">]</span>

                <span class="n">translate_probe</span> <span class="o">=</span> <span class="n">translate_probe</span> <span class="o">+</span> <span class="n">maxima</span>
            <span class="c1"># print(priority_atom_type, len(translate_probe))</span>
            <span class="k">return</span> <span class="n">translate_probe</span>

        <span class="k">def</span> <span class="nf">generate_rand_quaternions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Returns a list of random quaternions. Length matches settings.nrotations</span>

<span class="sd">            :return: tup, (a,b,c,d)</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">quaternions</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">nrotations</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">nrotations</span><span class="p">:</span>
                    <span class="n">r1</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">r2</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">s1</span> <span class="o">=</span> <span class="n">r1</span> <span class="o">*</span> <span class="n">r1</span> <span class="o">+</span> <span class="n">r2</span> <span class="o">*</span> <span class="n">r2</span>
                    <span class="k">if</span> <span class="n">s1</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">r3</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="n">r4</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

                        <span class="n">s2</span> <span class="o">=</span> <span class="n">r3</span> <span class="o">*</span> <span class="n">r3</span> <span class="o">+</span> <span class="n">r4</span> <span class="o">*</span> <span class="n">r4</span>
                        <span class="k">if</span> <span class="n">s2</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r3</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">s1</span><span class="p">)</span> <span class="o">/</span> <span class="n">s2</span><span class="p">)),</span> <span class="n">r4</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">s1</span><span class="p">)</span> <span class="o">/</span> <span class="n">s2</span><span class="p">)))</span>
                            <span class="n">quaternions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

                            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">return</span> <span class="n">quaternions</span>

        <span class="nd">@staticmethod</span>
        <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Calculate geometric mean of scores</span>

<span class="sd">            :param values: float, scores of atoms in probe</span>
<span class="sd">            :return: float, geometric mean of probe atom scores</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">sample_pose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">active_atoms_dic</span><span class="p">,</span> <span class="n">probe</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Return a pose score (as defined by the score(self,dic) function) and a dictionary of atom:scores</span>

<span class="sd">            :param trans: list of translations</span>
<span class="sd">            :param active_atoms_dic: dict {&quot;interaction type&quot;: &quot;atoms to be scored&quot;}</span>
<span class="sd">            :param probe: str, interaction_type</span>
<span class="sd">            :return:</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">if</span> <span class="n">probe</span> <span class="o">==</span> <span class="s2">&quot;negative&quot;</span> <span class="ow">or</span> <span class="n">probe</span> <span class="o">==</span> <span class="s2">&quot;positive&quot;</span><span class="p">:</span>
                <span class="n">atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grids</span> <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;positive&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">weight</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">6</span> <span class="o">/</span> <span class="nb">len</span><span class="p">([</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">atoms</span> <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">atomic_symbol</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span><span class="p">]))</span>

                <span class="n">apolar_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">active_atoms_dic</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="n">trans</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grids</span> <span class="k">if</span>
                                 <span class="nb">len</span><span class="p">(</span><span class="n">active_atoms_dic</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">name</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">g</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;apolar&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">weight</span>
                <span class="n">charged_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">active_atoms_dic</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="n">trans</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grids</span> <span class="k">if</span>
                                  <span class="nb">len</span><span class="p">(</span><span class="n">active_atoms_dic</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">name</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">g</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;apolar&quot;</span><span class="p">]</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">apolar_values</span> <span class="o">+</span> <span class="n">charged_values</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">active_atoms_dic</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="n">trans</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grids</span> <span class="k">if</span>
                          <span class="nb">len</span><span class="p">(</span><span class="n">active_atoms_dic</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">name</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">values</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">update_out_grids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">active_coordinates_dic</span><span class="p">,</span> <span class="n">trans</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            For active atoms for a given grid, set closest grid point value to score, unless already set to a higher</span>
<span class="sd">            value</span>

<span class="sd">            :param score: float, score of a given probe</span>
<span class="sd">            :param active_coordinates_dic:</span>
<span class="sd">            :param trans: list of translations</span>
<span class="sd">            :return:</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">for</span> <span class="n">pg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">probe_grids</span><span class="p">:</span>
                <span class="n">actives</span> <span class="o">=</span> <span class="n">active_coordinates_dic</span><span class="p">[</span><span class="n">pg</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">actives</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">actives</span><span class="p">:</span>
                    <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_point_to_indices</span><span class="p">(</span><span class="n">pg</span><span class="o">.</span><span class="n">add_coordinates</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">trans</span><span class="p">),</span> <span class="n">pg</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
                    <span class="n">pg</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">score</span><span class="p">,</span> <span class="n">pg</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)))</span>

        <span class="k">def</span> <span class="nf">get_active_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Returns a dictionary of {grid_name:[Coordinates]}</span>

<span class="sd">            :return:</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">active_coords_dic</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">g</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">coordinates</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">_active_atoms</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grids</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="n">active_coords_dic</span>

        <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">molecule</span><span class="p">,</span> <span class="n">probe</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Sample the grids according to the settings</span>

<span class="sd">            :param molecule:</span>
<span class="sd">            :param probe: str, interaction type, (donor, acceptor, negative, positive, apolar)</span>
<span class="sd">            :return:</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">high_scoring_probes</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">priority_atom</span><span class="p">,</span> <span class="n">priority_atom_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_priority_atom</span><span class="p">(</span><span class="n">molecule</span><span class="p">)</span>
            <span class="n">translate_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_translation_points</span><span class="p">(</span><span class="n">priority_atom_type</span><span class="p">)</span>
            <span class="n">molecule</span><span class="o">.</span><span class="n">remove_hydrogens</span><span class="p">()</span>
            <span class="n">quaternions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_rand_quaternions</span><span class="p">()</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Q&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">quaternions</span><span class="p">),</span> <span class="s2">&quot;P&quot;</span><span class="p">,</span> <span class="n">probe</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grids</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">set_molecule</span><span class="p">(</span><span class="n">molecule</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">probe_grids</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">set_molecule</span><span class="p">(</span><span class="n">molecule</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">polar_contributions</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">quaternions</span><span class="p">:</span>
                <span class="n">molecule</span><span class="o">.</span><span class="n">apply_quaternion</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
                <span class="n">priority_atom_coordinates</span> <span class="o">=</span> <span class="n">priority_atom</span><span class="o">.</span><span class="n">coordinates</span>
                <span class="n">active_coordinates_dic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_active_coordinates</span><span class="p">()</span>

                <span class="k">for</span> <span class="n">priority_atom_point</span> <span class="ow">in</span> <span class="n">translate_points</span><span class="p">:</span>

                    <span class="n">translation</span> <span class="o">=</span> <span class="p">[</span><span class="n">priority_atom_point</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">priority_atom_coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                                   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">priority_atom_coordinates</span><span class="p">))]</span>

                    <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_pose</span><span class="p">(</span><span class="n">translation</span><span class="p">,</span> <span class="n">active_coordinates_dic</span><span class="p">,</span> <span class="n">probe</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">score</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">score</span> <span class="o">&gt;</span> <span class="mi">14</span><span class="p">:</span>
                        <span class="n">m</span> <span class="o">=</span> <span class="n">molecule</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                        <span class="n">m</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">translation</span><span class="p">)</span>
                        <span class="n">m</span><span class="o">.</span><span class="n">identifier</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>

                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">high_scoring_probes</span><span class="p">[</span><span class="n">score</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                            <span class="n">high_scoring_probes</span><span class="p">[</span><span class="n">score</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">update_out_grids</span><span class="p">(</span><span class="n">score</span><span class="p">,</span> <span class="n">active_coordinates_dic</span><span class="p">,</span> <span class="n">translation</span><span class="p">)</span>

            <span class="n">sampled_probes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">high_scoring_probes</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">(),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="n">sampled_probes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">high_scoring_probes</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sampled_probes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">10000</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">sampled_probes</span><span class="p">[:</span><span class="mi">10000</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">sampled_probes</span>


    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">settings</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_grids</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">superstar_grids</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weighted_grids</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampled_probes</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">prot</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fname</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">probe_size</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">charged_probes</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">out_dir</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wrk_dir</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">settings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sampler_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Sampler</span><span class="o">.</span><span class="n">Settings</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sampler_settings</span> <span class="o">=</span> <span class="n">settings</span>

    <span class="k">def</span> <span class="nf">_get_cavity_centroid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cav</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the centroid of a cavity object</span>

<span class="sd">        :param cav:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">x_coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">y_coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">z_coords</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">feat</span> <span class="ow">in</span> <span class="n">cav</span><span class="o">.</span><span class="n">features</span><span class="p">:</span>
            <span class="n">feature_coords</span> <span class="o">=</span> <span class="n">feat</span><span class="o">.</span><span class="n">coordinates</span>
            <span class="n">x_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">feature_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">y_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">feature_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">z_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">feature_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="n">x_avg</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x_coords</span><span class="p">))</span>
        <span class="n">y_avg</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y_coords</span><span class="p">))</span>
        <span class="n">z_avg</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">z_coords</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">x_avg</span><span class="p">,</span> <span class="n">y_avg</span><span class="p">,</span> <span class="n">z_avg</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_superstar_job</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        creates a RunSuperstar class and returns a SuperstarResult object</span>
<span class="sd">        :param args: tuple, probe name and centroid</span>
<span class="sd">        :return: a :class: `__main__().SuperstarResult` object</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">_RunSuperstar</span><span class="p">()</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">ss_probe</span><span class="p">,</span> <span class="n">centroid</span><span class="p">,</span> <span class="n">prot</span><span class="p">,</span> <span class="n">out_dir</span><span class="p">,</span> <span class="n">wrk_dir</span> <span class="o">=</span> <span class="n">args</span>
        <span class="n">s</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">jobname</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">.ins&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">s</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">probename</span> <span class="o">=</span> <span class="n">ss_probe</span>
        <span class="n">s</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">moleculefile</span> <span class="o">=</span> <span class="s2">&quot;protein.pdb&quot;</span>
        <span class="n">s</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">cavity_origin</span> <span class="o">=</span> <span class="n">centroid</span>
        <span class="n">s</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">working_directory</span> <span class="o">=</span> <span class="n">wrk_dir</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">run_superstar</span><span class="p">(</span><span class="n">prot</span><span class="p">,</span> <span class="n">out_dir</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_run_ss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">centroid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        initiates a SuperStar run for a given protein and probe</span>

<span class="sd">        :param prot: a :class:`ccdc.protein.Protein` instance</span>
<span class="sd">        :param out_dir: str, output directory</span>
<span class="sd">        :param centroid: tup, coordinates of cavity origin</span>
<span class="sd">        :param charged_probes: bool, if True &#39;positive&#39; and &#39;negative&#39; probes will be used</span>
<span class="sd">        :return: a :class:`SuperstarResult` instance</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">charged_probes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">probe_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="n">apolar</span><span class="o">=</span><span class="s1">&#39;AROMATIC CH CARBON&#39;</span><span class="p">,</span>
                <span class="n">donor</span><span class="o">=</span><span class="s1">&#39;UNCHARGED NH NITROGEN&#39;</span><span class="p">,</span>
                <span class="n">acceptor</span><span class="o">=</span><span class="s1">&#39;CARBONYL OXYGEN&#39;</span><span class="p">,</span>
                <span class="n">positive</span><span class="o">=</span><span class="s1">&#39;CHARGED NH NITROGEN&#39;</span><span class="p">,</span>
                <span class="n">negative</span><span class="o">=</span><span class="s1">&#39;CARBOXYLATE OXYGEN&#39;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">probe_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="n">apolar</span><span class="o">=</span><span class="s1">&#39;AROMATIC CH CARBON&#39;</span><span class="p">,</span>
                <span class="n">donor</span><span class="o">=</span><span class="s1">&#39;UNCHARGED NH NITROGEN&#39;</span><span class="p">,</span>
                <span class="n">acceptor</span><span class="o">=</span><span class="s1">&#39;CARBONYL OXYGEN&#39;</span><span class="p">)</span>

        <span class="n">wrk_dir</span> <span class="o">=</span> <span class="n">_test_output_dir</span><span class="p">()</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">probe_dict</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">centroid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_dir</span><span class="p">,</span> <span class="n">wrk_dir</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">probe_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
        <span class="n">ex</span> <span class="o">=</span> <span class="n">futures</span><span class="o">.</span><span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_superstar_job</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_weighted_maps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        weight superstar output by burriedness</span>

<span class="sd">        :return: a list of :class: `WeightedResult` instances</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">superstar_grids</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ghecom_executable</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">buriedness</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ghecom</span><span class="o">.</span><span class="n">grid</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">buriedness</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">ligsite</span>

            <span class="n">s</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">buriedness</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_common_grid</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">buriedness</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">weighted_grid</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">grid</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">buriedness</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_WeightedResult</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">weighted_grid</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">results</span>

    <span class="k">def</span> <span class="nf">_get_out_maps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">grid_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to organise sampling of weighted superstar maps by molecular probes</span>

<span class="sd">        :param probe:</span>
<span class="sd">        :param grid_dict:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">donor_grid</span> <span class="o">=</span> <span class="n">_SampleGrid</span><span class="p">(</span><span class="s1">&#39;donor&#39;</span><span class="p">,</span> <span class="n">grid_dict</span><span class="p">[</span><span class="s1">&#39;donor&#39;</span><span class="p">],</span> <span class="n">_SampleGrid</span><span class="o">.</span><span class="n">is_donor</span><span class="p">)</span>
        <span class="n">acceptor_grid</span> <span class="o">=</span> <span class="n">_SampleGrid</span><span class="p">(</span><span class="s1">&#39;acceptor&#39;</span><span class="p">,</span> <span class="n">grid_dict</span><span class="p">[</span><span class="s1">&#39;acceptor&#39;</span><span class="p">],</span> <span class="n">_SampleGrid</span><span class="o">.</span><span class="n">is_acceptor</span><span class="p">)</span>
        <span class="n">apolar_grid</span> <span class="o">=</span> <span class="n">_SampleGrid</span><span class="p">(</span><span class="s1">&#39;apolar&#39;</span><span class="p">,</span> <span class="n">grid_dict</span><span class="p">[</span><span class="s1">&#39;apolar&#39;</span><span class="p">],</span> <span class="n">_SampleGrid</span><span class="o">.</span><span class="n">is_apolar</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">charged_probes</span><span class="p">:</span>
            <span class="n">negative_grid</span> <span class="o">=</span> <span class="n">_SampleGrid</span><span class="p">(</span><span class="s1">&#39;negative&#39;</span><span class="p">,</span> <span class="n">grid_dict</span><span class="p">[</span><span class="s1">&#39;negative&#39;</span><span class="p">],</span> <span class="n">_SampleGrid</span><span class="o">.</span><span class="n">is_negative</span><span class="p">)</span>
            <span class="n">positive_grid</span> <span class="o">=</span> <span class="n">_SampleGrid</span><span class="p">(</span><span class="s1">&#39;positive&#39;</span><span class="p">,</span> <span class="n">grid_dict</span><span class="p">[</span><span class="s1">&#39;positive&#39;</span><span class="p">],</span> <span class="n">_SampleGrid</span><span class="o">.</span><span class="n">is_positive</span><span class="p">)</span>

        <span class="n">kw</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;settings&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler_settings</span><span class="p">}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">charged_probes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Sampler</span><span class="p">(</span><span class="n">apolar_grid</span><span class="p">,</span> <span class="n">donor_grid</span><span class="p">,</span> <span class="n">acceptor_grid</span><span class="p">,</span> <span class="n">negative_grid</span><span class="p">,</span> <span class="n">positive_grid</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Sampler</span><span class="p">(</span><span class="n">apolar_grid</span><span class="p">,</span> <span class="n">donor_grid</span><span class="p">,</span> <span class="n">acceptor_grid</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

        <span class="n">probe_path</span> <span class="o">=</span> <span class="n">pkg_resources</span><span class="o">.</span><span class="n">resource_filename</span><span class="p">(</span><span class="s1">&#39;fragment_hotspot_maps&#39;</span><span class="p">,</span> <span class="s1">&#39;probes/&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">charged_probes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">probe</span> <span class="o">==</span> <span class="s2">&quot;negative&quot;</span> <span class="ow">or</span> <span class="n">probe</span> <span class="o">==</span> <span class="s2">&quot;positive&quot;</span><span class="p">:</span>
                <span class="n">mol</span> <span class="o">=</span> <span class="n">MoleculeReader</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">probe_path</span><span class="p">,</span> <span class="s2">&quot;rotate-</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">_flat.mol2&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="s2">&quot;test&quot;</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mol</span> <span class="o">=</span> <span class="n">MoleculeReader</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">probe_path</span><span class="p">,</span> <span class="s2">&quot;rotate-</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">_flat.mol2&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">probe_size</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mol</span> <span class="o">=</span> <span class="n">MoleculeReader</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">probe_path</span><span class="p">,</span> <span class="s2">&quot;rotate-</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">_flat.mol2&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">probe_size</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">probes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">probe</span><span class="o">=</span><span class="n">probe</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">pg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">probe_grids</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pg</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">probe</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">out_grids</span><span class="p">[</span><span class="n">pg</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pg</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">out_grids</span><span class="p">[</span><span class="n">pg</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">pg</span><span class="o">.</span><span class="n">grid</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">probes</span>

    <span class="k">def</span> <span class="nf">_calc_hotspots</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function for overall organisation of hotspot calculation</span>

<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Start SS&quot;</span><span class="p">)</span>

        <span class="n">probe_types</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;apolar&#39;</span><span class="p">,</span> <span class="s1">&#39;donor&#39;</span><span class="p">,</span> <span class="s1">&#39;acceptor&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">charged_probes</span><span class="p">:</span>
            <span class="n">probe_types</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;negative&#39;</span><span class="p">,</span> <span class="s1">&#39;positive&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">superstar_grids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_ss</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">centroid</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;SS complete&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ghecom_executable</span><span class="p">:</span>
            <span class="n">out_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy_and_clear</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">superstar_grids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ligsite</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">_RunGhecom</span><span class="p">()</span>
            <span class="n">r</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">prot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prot</span>
            <span class="n">r</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">out_grid</span> <span class="o">=</span> <span class="n">out_grid</span>
            <span class="n">r</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">ghecom_executable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ghecom_executable</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ghecom</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">run_ghecom</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">weighted_grids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_weighted_maps</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buriedness</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_dir</span><span class="p">,</span> <span class="s2">&quot;buriedness.grd&quot;</span><span class="p">))</span>

        <span class="n">grid_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">w</span><span class="o">.</span><span class="n">identifier</span><span class="p">:</span> <span class="n">w</span><span class="o">.</span><span class="n">grid</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted_grids</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">probe</span> <span class="ow">in</span> <span class="n">probe_types</span><span class="p">:</span>
            <span class="n">top_probes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_out_maps</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="n">grid_dict</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sampled_probes</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">probe</span><span class="p">:</span> <span class="n">top_probes</span><span class="p">})</span>

<div class="viewcode-block" id="Hotspots.from_grid_dic"><a class="viewcode-back" href="../../hotspot_api.html#fragment_hotspot_maps.fragment_hotspot_maps.Hotspots.from_grid_dic">[docs]</a>    <span class="k">def</span> <span class="nf">from_grid_dic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">super_grids</span><span class="p">,</span> <span class="n">prot</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sampled_probes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">buriedness</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a Hotspots_reults object from a dictionary of previously calculated grid objects</span>

<span class="sd">        :param super_grids: dict, {&#39;probe_name&#39;:grid} where the probe names are &#39;apolar&#39;, &#39;donor&#39; and &#39;acceptor&#39;</span>
<span class="sd">        :param prot: a :class:`ccdc.protein.Protein` instance</span>
<span class="sd">        :param fname: str, file path</span>
<span class="sd">        :return: a :class:`fragment_hotspots.Hotspot.HotspotResults` instance</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fname</span> <span class="o">=</span> <span class="n">fname</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span> <span class="o">=</span> <span class="n">super_grids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prot</span> <span class="o">=</span> <span class="n">prot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampled_probes</span> <span class="o">=</span> <span class="n">sampled_probes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buriedness</span> <span class="o">=</span> <span class="n">buriedness</span>
        <span class="k">return</span> <span class="n">HotspotResults</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampled_probes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">buriedness</span><span class="p">,</span>
                                   <span class="n">out_dir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">out_dir</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hotspots.from_protein"><a class="viewcode-back" href="../../hotspot_api.html#fragment_hotspot_maps.fragment_hotspot_maps.Hotspots.from_protein">[docs]</a>    <span class="k">def</span> <span class="nf">from_protein</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prot</span><span class="p">,</span> <span class="n">charged_probes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="s1">&#39;protein.pdb&#39;</span><span class="p">,</span> <span class="n">binding_site_origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">probe_size</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span>
                     <span class="n">ghecom_executable</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate Fragment Hotspot Maps from a ccdc.protein.Protein object</span>

<span class="sd">        :param prot: a :class:`ccdc.protein.Protein` instance</span>
<span class="sd">        :param fname: str, path of input protein</span>
<span class="sd">        :param binding_site_origin: a tuple of three floats, giving a coordinate within the binding site</span>
<span class="sd">        :param probe_size: int, size of probe in number of heavy atoms (3-8 atoms)</span>
<span class="sd">        :param ghecom_executable: str, path to ghecom executeable, if None ligsite used</span>
<span class="sd">        :param charged_probes: bool, if True include positive and negative probes</span>
<span class="sd">        :return: a :class:`fragment_hotspots.Hotspot.HotspotResults` instance</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">prot</span> <span class="o">=</span> <span class="n">prot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fname</span> <span class="o">=</span> <span class="n">fname</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">probe_size</span> <span class="o">=</span> <span class="n">probe_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">charged_probes</span> <span class="o">=</span> <span class="n">charged_probes</span>
        <span class="n">od</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fname</span><span class="p">),</span> <span class="s2">&quot;out&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">(</span><span class="n">od</span><span class="p">):</span>
            <span class="n">mkdir</span><span class="p">(</span><span class="n">od</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_dir</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fname</span><span class="p">),</span> <span class="s2">&quot;out&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wrk_dir</span> <span class="o">=</span> <span class="n">getcwd</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_dir</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ghecom_executable</span> <span class="o">=</span> <span class="n">ghecom_executable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">centroid</span> <span class="o">=</span> <span class="n">binding_site_origin</span>

        <span class="k">with</span> <span class="n">MoleculeWriter</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_dir</span><span class="p">,</span> <span class="s1">&#39;protein.pdb&#39;</span><span class="p">))</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
            <span class="n">w</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prot</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_calc_hotspots</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">probe</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_grids</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">probe</span> <span class="o">=</span> <span class="n">probe</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="n">sg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_grids</span><span class="p">[</span><span class="n">probe</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="n">probe</span><span class="p">]</span> <span class="o">=</span> <span class="n">sg</span>
        <span class="k">return</span> <span class="n">HotspotResults</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampled_probes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">buriedness</span><span class="p">,</span>
                                   <span class="n">out_dir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">out_dir</span><span class="p">)</span></div></div>




<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># parser = argparse.ArgumentParser(description=&#39;&#39;&#39;Calculate Fragment Hotspot Maps from a protonated protein structure.</span>
    <span class="c1">#     Any waters or ligands included in the protein file will be included as part of the calculation. Run the file &quot;</span>
    <span class="c1">#     pymol_results_file.py&quot; in pymol in order to visualise the results&#39;&#39;&#39;)</span>
    <span class="c1">#</span>
    <span class="c1"># parser.add_argument(&#39;-protein&#39;, help=&#39;Path to input protein PDB or Mol2 file&#39;, required=True)</span>
    <span class="c1"># parser.add_argument(&#39;-ghecom_exe&#39;, help=&#39;Path to Ghecom executable (recommended)&#39;)</span>
    <span class="c1">#</span>
    <span class="c1"># args = parser.parse_args()</span>
    <span class="c1"># prot_file = args.protein</span>
    <span class="c1"># out_dir = args.out_dir</span>
    <span class="c1"># ghecom_exe = args.ghecom_exe</span>

    <span class="n">prot_file</span> <span class="o">=</span> <span class="s2">&quot;Z:/fragment_hotspot_maps/protein.pdb&quot;</span>
    <span class="n">ghecom_exe</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">prot</span> <span class="o">=</span> <span class="n">Protein</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">prot_file</span><span class="p">)</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">Hotspots</span><span class="p">()</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">from_protein</span><span class="p">(</span><span class="n">prot</span><span class="o">=</span><span class="n">prot</span><span class="p">,</span> <span class="n">charged_probes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="n">prot_file</span><span class="p">,</span> <span class="n">ghecom_executable</span><span class="o">=</span><span class="n">ghecom_exe</span><span class="p">)</span>
    <span class="n">result</span><span class="o">.</span><span class="n">output_pymol_file</span><span class="p">(</span><span class="n">out_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Chris Radoux and Peter Curran.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.11</a>
      
    </div>

    

    
  </body>
</html>